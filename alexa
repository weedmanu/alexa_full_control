#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
============================================================================
üéôÔ∏è  Alexa Voice Control CLI - Architecture Modulaire
Interface en ligne de commande pour contr√¥ler Amazon Alexa
Compatible: Windows, macOS, Linux
============================================================================

Usage:
    alexa <CATEGORY> <ACTION> [OPTIONS]

Exemples:
    alexa auth create
    alexa device list
    alexa music play -d "Salon Echo" -s "Soleil bleu"
    alexa timer create -d "Cuisine" --duration 10 --label "P√¢tes"
    alexa smarthome control --entity light.salon --action on

Pour plus d'aide:
    alexa --help
    alexa <CATEGORY> --help
    alexa <CATEGORY> <ACTION> --help

Auteur: M@nu
Version: 2.0.0
Date: 8 octobre 2025
============================================================================
"""

import sys
from pathlib import Path
from typing import Any, Optional
import io

# Forcer l'encodage UTF-8 pour stdout/stderr sur Windows
if sys.platform == 'win32':
    sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8', errors='replace')
    sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8', errors='replace')

# Ajouter le r√©pertoire parent au PYTHONPATH pour les imports
sys.path.insert(0, str(Path(__file__).parent))

# Logger global avec loguru
from loguru import logger

from cli import create_context, create_parser
from cli.commands import (
    ActivityCommand,
    AnnouncementCommand,
    AuthCommand,
    CacheCommand,
    CalendarCommand,
    DeviceCommand,
    DNDCommand,
    ListsCommand,
    MultiroomCommand,
    MusicCommand,
    RoutineCommand,
    SmartHomeCommand,
    TimerCommand,
)
from utils.logger import setup_loguru_logger


# Configuration du logging utilisant la fonction centralis√©e
def setup_logging(verbose: bool = False, debug: bool = False):
    """
    Configure le logging am√©lior√© avec loguru via la fonction centralis√©e.

    Args:
        verbose: Mode verbeux (niveau INFO)
        debug: Mode debug (niveau DEBUG)
    """
    # D√©terminer le niveau de log
    if debug:
        level = "DEBUG"
    elif verbose:
        level = "INFO"
    else:
        level = "WARNING"

    # Fichier de log en mode debug
    log_file = None
    if debug:
        log_file = Path("logs") / "alexa_cli.log"

    # Utiliser la fonction centralis√©e du module utils.logger
    setup_loguru_logger(
        log_file=log_file,
        level=level,
        ensure_utf8=True,
    )


def register_all_commands(parser: Any) -> None:
    """
    Enregistre toutes les commandes disponibles.

    Args:
        parser: CommandParser
    """
    # Phase 1 - Sprint 1 ‚úÖ
    parser.register_command('auth', AuthCommand)
    parser.register_command('device', DeviceCommand)

    # Phase 2 - Sprint 2 ‚úÖ
    parser.register_command('music', MusicCommand)
    parser.register_command('timers', TimerCommand)
    # alarm et reminder sont maintenant des sous-cat√©gories de timers

    # Phase 3 - Sprint 3 ‚úÖ
    parser.register_command('smarthome', SmartHomeCommand)

    # Phase 4 - Sprint 4 ‚úÖ
    parser.register_command('announcement', AnnouncementCommand)
    parser.register_command('dnd', DNDCommand)
    # announcement: SUPPRIM√â - Drop-in bloqu√© par Amazon (privacy)

    # Phase 5 - Sprint 5 ‚úÖ
    parser.register_command('activity', ActivityCommand)
    parser.register_command('calendar', CalendarCommand)
    parser.register_command('lists', ListsCommand)

    # Phase 6 - Sprint 6 ‚úÖ
    parser.register_command('routine', RoutineCommand)
    parser.register_command('multiroom', MultiroomCommand)

    # Cache management
    parser.register_command('cache', CacheCommand)


def main() -> int:
    """
    Point d'entr√©e principal de la CLI.
    
    Returns:
        Code de sortie (0 = succ√®s, >0 = erreur)
    """
    try:
        # Configuration temporaire du logging (tr√®s silencieux)
        logger.remove()
        logger.add(sys.stdout, level="CRITICAL", format="{message}")  # Seulement CRITICAL
        
        # Cr√©er le parser
        parser = create_parser(version="2.0.0")
        
        # Enregistrer toutes les commandes
        register_all_commands(parser)
        
        # Parser les arguments
        # Si -h est pass√© apr√®s une action, c'est une erreur car -h n'existe qu'au niveau cat√©gorie
        if '-h' in sys.argv and len(sys.argv) > 3:
            # Il y a au moins: script, category, action, -h
            # V√©rifier si -h vient apr√®s une action (position 3+)
            if sys.argv[-1] == '-h' or (len(sys.argv) > 3 and '-h' in sys.argv[3:]):
                # Sauvegarder les arguments originaux
                original_argv = sys.argv.copy()
                
                # Afficher l'erreur explicite que -h n'est pas support√© au niveau action
                print("alexa: error: unrecognized arguments: -h")
                print()
                print("üí° L'option -h n'est disponible qu'au niveau de la cat√©gorie, pas au niveau de l'action")
                print()
                
                # Afficher l'aide de la cat√©gorie
                sys.argv = [original_argv[0], original_argv[1], '-h']
                args = parser.parse_args()
                sys.exit(0)
        
        args = parser.parse_args()
        
        # Configurer le logging d√©finitif avec les bonnes options
        verbose_mode = args.verbose if hasattr(args, 'verbose') else False
        debug_mode = args.debug if hasattr(args, 'debug') else False
        
        setup_logging(verbose=verbose_mode, debug=debug_mode)
        
        logger.info(f"Alexa Voice Control CLI v2.0.0 - Cat√©gorie: {args.category}")
        
        # Cr√©er le contexte
        config_file = args.config if hasattr(args, 'config') and args.config else None
        context = create_context(config_file=config_file)
        
        # Charger l'authentification (sauf pour auth login)
        # Si les cookies existent, initialiser l'auth dans le contexte
        if not (args.category == 'auth' and args.action == 'login'):
            try:
                from alexa_auth.alexa_auth import AlexaAuth
                from core.state_machine import ConnectionState

                # Charger l'authentification avec cache
                auth = AlexaAuth(cache_service=context.cache_service)
                if auth.load_cookies():
                    # D√©finir l'√©tat initial AUTHENTICATED (credentials valides) AVANT initialize_auth
                    context.state_machine.set_initial_state(ConnectionState.AUTHENTICATED)
                    context.initialize_auth(auth)
                    logger.debug(f"Authentification charg√©e: {auth.get_cookie_info()}")
                else:
                    logger.debug("Pas de cookies valides trouv√©s")
            except Exception as e:
                logger.debug(f"Impossible de charger l'auth: {e}")
        
        # R√©cup√©rer la classe de commande
        command_class = parser.get_command_class(args.category)
        
        if not command_class:
            logger.error(f"Commande '{args.category}' non trouv√©e")
            print(f"‚ùå Erreur: Cat√©gorie '{args.category}' non reconnue", file=sys.stderr)
            return 1
        
        # Cr√©er l'instance de commande avec le contexte
        command = command_class(context)
        
        # Ex√©cuter la commande
        success = command.execute(args)
        
        # Nettoyer le contexte
        context.cleanup()
        
        # Retourner le code de sortie
        return 0 if success else 1
    
    except KeyboardInterrupt:
        print("\n‚ö†Ô∏è  Interruption par l'utilisateur", file=sys.stderr)
        logger.warning("Interruption par Ctrl+C")
        return 130
    
    except Exception as e:
        logger.exception("Erreur non g√©r√©e dans main()")
        print(f"‚ùå Erreur inattendue: {e}", file=sys.stderr)
        return 1


if __name__ == '__main__':
    sys.exit(main())
