#!/usr/bin/env python3
"""
============================================================================
üéôÔ∏è  Alexa Voice Control CLI - Architecture Modulaire
Interface en ligne de commande pour contr√¥ler Amazon Alexa
Compatible: Windows, macOS, Linux
============================================================================

Usage:
    alexa <CATEGORY> <ACTION> [OPTIONS]

Exemples:
    
    alexa device list
    alexa music play -d "Salon Echo" -s "Soleil bleu"
    alexa timer create -d "Cuisine" --duration 10 --label "P√¢tes"
    alexa smarthome control --entity light.salon --action on

Pour plus d'aide:
    alexa --help
    alexa <CATEGORY> --help
    alexa <CATEGORY> <ACTION> --help

Auteur: M@nu
Version: {__version__}
Date: 8 octobre 2025
============================================================================
"""

# Version centralis√©e - SINGLE SOURCE OF TRUTH
__version__ = "2.0.0"

import io
import sys
from pathlib import Path
from typing import Any, List, Dict, cast

# Forcer l'encodage UTF-8 pour stdout/stderr sur Windows **seulement** lorsque
# le script est ex√©cut√© directement. R√©affecter sys.stdout/stderr √† l'import
# peut casser les frameworks de test (pytest) qui remplacent ces streams.
if __name__ == "__main__" and sys.platform == "win32":
    try:
        sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding="utf-8", errors="replace")
        sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding="utf-8", errors="replace")
    except Exception:
        # Si pour une raison quelconque les streams ne sont pas standard
        # (par ex. capture de pytest), ne pas √©chouer √† l'import.
        pass

# Ajouter le r√©pertoire parent au PYTHONPATH pour les imports
sys.path.insert(0, str(Path(__file__).parent))

# Logger global avec loguru
from loguru import logger
# Retirer le sink par d√©faut de Loguru pour √©viter les logs non sollicit√©s
# lors de l'import de modules. Le sink sera r√©-ajout√© explicitement dans
# `setup_logging()` uniquement si --debug ou --verbose est demand√©.
try:
    logger.remove()
except Exception:
    pass

from utils.cli import create_context, create_parser
from utils.cli.command_adapter import get_command_adapter
from commands import (
    ActivityCommand,
    AlarmCommand,
    AnnouncementCommand,
    AuthCommand,
    CacheCommand,
    CalendarCommand,
    CountdownCommand,
    DeviceCommand,
    DNDCommand,
    FavoriteCommand,
    LibraryCommand,
    ListsCommand,
    MultiroomCommand,
    PlaybackCommand,
    RadioCommand,
    ReminderCommand,
    RoutineCommand,
    ScenarioCommand,
    SmartHomeCommand,
)
from utils.logger import setup_loguru_logger
# Deprecated: short help generator removed in favor of argparse's native help


# Configuration du logging utilisant la fonction centralis√©e
def setup_logging(verbose: bool = False, debug: bool = False, no_color: bool = False):
    """
    Configure le logging am√©lior√© avec loguru via la fonction centralis√©e.

    Args:
        verbose: Mode verbeux (niveau INFO)
        debug: Mode debug (niveau DEBUG)
    """
    # D√©terminer le niveau de log
    if debug:
        level = "DEBUG"
    elif verbose:
        level = "INFO"
    else:
        # Mode quiet par d√©faut : n'afficher que les erreurs
        level = "ERROR"

    # Fichier de log en mode debug
    log_file = None
    if debug:
        log_file = Path("logs") / "alexa_cli.log"

    # Utiliser la fonction centralis√©e du module utils.logger
    # Passer `no_color` uniquement si activ√© pour ne pas modifier la signature
    if no_color:
        setup_loguru_logger(log_file=log_file, level=level, enable_console=True, ensure_utf8=True, no_color=True)
    else:
        setup_loguru_logger(log_file=log_file, level=level, enable_console=True, ensure_utf8=True)


def register_all_commands(parser: Any) -> None:
    """
    Enregistre toutes les commandes disponibles.

    Args:
        parser: CommandParser
    """
    # Phase 1 - Sprint 1 ‚úÖ
    parser.register_command("auth", AuthCommand)
    parser.register_command("device", DeviceCommand)

    # Phase 1.6 - Favorites ‚úÖ NEW
    parser.register_command("favorite", FavoriteCommand)

    # Phase 1.7 - Multiroom ‚úÖ NEW
    parser.register_command("multiroom", MultiroomCommand)

    # Phase 1.8 - Scenarios ‚úÖ NEW
    parser.register_command("scenario", ScenarioCommand)
    parser.register_command("announcement", AnnouncementCommand)

    # Phase 2 - Sprint 2 ‚úÖ (musique scind√©e en sous-cat√©gories)
    # Register only short music category names (no 'music' prefix)
    parser.register_command("library", LibraryCommand)
    parser.register_command("playback", PlaybackCommand)
    parser.register_command("radio", RadioCommand)

    # Phase 3 - Sprint 3 ‚úÖ
    parser.register_command("smarthome", SmartHomeCommand)

    # Timers split into explicit top-level categories: alarms, reminders, countdown
    parser.register_command("alarms", AlarmCommand)
    parser.register_command("reminders", ReminderCommand)
    parser.register_command("countdown", CountdownCommand)

    # Phase 4 - Sprint 4 ‚úÖ
    parser.register_command("dnd", DNDCommand)

    # Phase 5 - Sprint 5 ‚úÖ
    parser.register_command("activity", ActivityCommand)
    parser.register_command("calendar", CalendarCommand)
    parser.register_command("lists", ListsCommand)

    # Phase 6 - Sprint 6 ‚úÖ
    parser.register_command("routine", RoutineCommand)

    # Cache management
    parser.register_command("cache", CacheCommand)


def main() -> int:
    """
    Point d'entr√©e principal de la CLI.

    Returns:
        Code de sortie (0 = succ√®s, >0 = erreur)
    """
    try:
    # Ne pas ajouter de sink log par d√©faut ici. L'initialisation compl√®te
    # du logging est effectu√©e par `setup_logging()` plus bas uniquement
    # lorsque l'utilisateur a demand√© `--verbose` ou `--debug`.

        # NOTE: top-level help handling moved below (after commands registered)

        # Cr√©er le parser
        parser = create_parser(version=__version__)

        # Enregistrer toutes les commandes
        register_all_commands(parser)

        # Si -h/--help demand√© au niveau top-level (ex: `alexa -h`), afficher
        # l'aide standard fournie par argparse et quitter. Si -h appara√Æt
        # apr√®s la cat√©gorie, laisser argparse g√©rer le d√©tail de la cat√©gorie.
        if ("-h" in sys.argv or "--help" in sys.argv) and len(sys.argv) > 1:
            flag = "-h" if "-h" in sys.argv else "--help"
            if sys.argv.index(flag) == 1:
                # Utiliser le help natif d'argparse pour la sortie concise
                parser.print_help()
                return 0

        # Parser les arguments
        # Si -h est pass√© apr√®s une action, c'est une erreur car -h n'existe qu'au niveau cat√©gorie
        if "-h" in sys.argv and len(sys.argv) > 3:
            # Il y a au moins: script, category, action, -h
            # V√©rifier si -h vient apr√®s une action (position 3+)
            if sys.argv[-1] == "-h" or (len(sys.argv) > 3 and "-h" in sys.argv[3:]):
                # Sauvegarder les arguments originaux
                original_argv = sys.argv.copy()

                # Afficher l'erreur explicite que -h n'est pas support√© au niveau action
                print("alexa: error: unrecognized arguments: -h")
                print()
                print("üí° L'option -h n'est disponible qu'au niveau de la cat√©gorie, pas au niveau de l'action")
                print()

                # Afficher l'aide de la cat√©gorie
                sys.argv = [original_argv[0], original_argv[1], "-h"]
                args = parser.parse_args()
                sys.exit(0)

        args = parser.parse_args()

        # Configurer le logging d√©finitif avec les bonnes options
        verbose_mode = getattr(args, "verbose", False)
        debug_mode = getattr(args, "debug", False)

        # Only pass --no-color when the attribute is present on args
        raw_no_color = getattr(args, "no_color", False)
        # If argparse produced a real bool, keep it. If tests used MagicMock, coerce to False.
        no_color_mode = raw_no_color if isinstance(raw_no_color, bool) else False

        # Toujours initialiser Loguru : par d√©faut (quiet) on affiche uniquement
        # les erreurs (niveau ERROR). Si --verbose/--debug est fourni, on √©l√®ve
        # le niveau en cons√©quence.
        if isinstance(raw_no_color, bool):
            setup_logging(verbose=verbose_mode, debug=debug_mode, no_color=no_color_mode)
        else:
            setup_logging(verbose=verbose_mode, debug=debug_mode)

        logger.info(f"Alexa Voice Control CLI v{__version__} - Cat√©gorie: {args.category}")

        # Cr√©er le contexte
        config_file = args.config if hasattr(args, "config") and args.config else None
        context = create_context(config_file=config_file)

        # Charger l'authentification (sauf pour auth login)
        # Si les cookies existent, initialiser l'auth dans le contexte
        if not (args.category == "auth" and args.action == "login"):
            try:
                from alexa_auth.alexa_auth import AlexaAuth
                from core.state_machine import ConnectionState

                # Charger l'authentification avec cache
                auth = AlexaAuth(cache_service=context.cache_service)
                if auth.load_cookies():
                    # Sanity check: tenter un ping minimal sur un endpoint devices
                    try:
                        resp = auth.get(f"https://alexa.{auth.amazon_domain}/api/devices-v2/device", timeout=10)
                        if getattr(resp, "status_code", None) == 200:
                            # Cookies et endpoint valides
                            context.state_machine.set_initial_state(ConnectionState.AUTHENTICATED)
                            context.initialize_auth(auth)
                            logger.debug(f"Authentification charg√©e: {auth.get_cookie_info()}")
                        else:
                            logger.warning(
                                f"Cookies pr√©sents mais ping API a renvoy√© {getattr(resp, 'status_code', 'unknown')}. Ne pas d√©finir comme authentifi√©"
                            )
                    except Exception as e:
                        logger.warning(f"Cookies charg√©s mais v√©rification API √©chou√©e: {e}")
                else:
                    logger.debug("Pas de cookies valides trouv√©s")
            except Exception as e:
                logger.debug(f"Impossible de charger l'auth: {e}")

        # R√©cup√©rer la classe de commande
        command_class = parser.get_command_class(args.category)

        if not command_class:
            if not args.category:
                logger.error("Aucune cat√©gorie sp√©cifi√©e")
            else:
                logger.error(f"Commande '{args.category}' non trouv√©e")
                print(f"‚ùå Erreur: Cat√©gorie '{args.category}' non reconnue", file=sys.stderr)
            return 1

        # Phase 1: Initialize DI Container (always) so managers are registered
        try:
            from core.di_container import setup_di_container

            # Pass context.auth (may be None) ‚Äî setup_di_container will register singletons
            # context.auth may be None at runtime; setup_di_container handles it.
            setup_di_container(context.auth, context.config, context.state_machine)  # type: ignore[arg-type]
            logger.debug("‚úÖ DI Container initialis√©")
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è  Erreur initialisation DI Container: {e}")

        # Cr√©er / ex√©cuter la commande
        adapter = get_command_adapter()

        # If it's a ManagerCommand, use the adapter factory to create and execute
        try:
            from utils.cli.command_template import ManagerCommand

            if issubclass(command_class, ManagerCommand):
                command = adapter.create_manager_command(command_class)
                result = adapter.execute_command(command, vars(args))
                # result is dict from ManagerCommand.validate_and_execute
                success = bool(result and result.get("success", False))

                # Display result if successful
                if success:
                    if result.get("formatted"):
                        print(result.get("formatted"))
                    if result.get("data"):
                        # If JSON output requested
                        if getattr(args, "json", False):
                            import json

                            print(json.dumps(result.get("data"), indent=2, ensure_ascii=False))
                        else:
                            # Display structured data (device list, etc)
                            data: Any = result.get("data")
                            if isinstance(data, list):
                                # Cast for the static analyzer now that we checked type
                                for item in cast(List[Dict[str, Any]], data):
                                    print(f"  - {item.get('accountName', 'Unknown')}")
                            else:
                                print(data)
                else:
                    # Display error message
                    if result.get("error"):
                        print(f"‚ùå Erreur: {result.get('error')}", file=sys.stderr)
            else:
                # Legacy path
                command = command_class(context)
                success = command.execute(args)
        except Exception:
            # Fallback to legacy behavior
            command = command_class(context)
            success = command.execute(args)

        # Nettoyer le contexte
        context.cleanup()

        # Retourner le code de sortie
        return 0 if success else 1

    except KeyboardInterrupt:
        print("\n‚ö†Ô∏è  Interruption par l'utilisateur", file=sys.stderr)
        logger.warning("Interruption par Ctrl+C")
        return 130

    except Exception as e:
        logger.exception("Erreur non g√©r√©e dans main()")
        print(f"‚ùå Erreur inattendue: {e}", file=sys.stderr)
        return 1


if __name__ == "__main__":
    sys.exit(main())
