#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
============================================================================
üéôÔ∏è  Alexa Voice Control CLI - Architecture Modulaire
Interface en ligne de commande pour contr√¥ler Amazon Alexa
Compatible: Windows, macOS, Linux
============================================================================

Usage:
    alexa <CATEGORY> <ACTION> [OPTIONS]

Exemples:
    alexa auth create
    alexa device list
    alexa music play -d "Salon Echo" -s "Soleil bleu"
    alexa timer create -d "Cuisine" --duration 10 --label "P√¢tes"
    alexa smarthome control --entity light.salon --action on

Pour plus d'aide:
    alexa --help
    alexa <CATEGORY> --help
    alexa <CATEGORY> <ACTION> --help

Auteur: M@nu
Version: 2.0.0
Date: 8 octobre 2025
============================================================================
"""

import io
import sys
from pathlib import Path
from typing import Any

# Forcer l'encodage UTF-8 pour stdout/stderr sur Windows **seulement** lorsque
# le script est ex√©cut√© directement. R√©affecter sys.stdout/stderr √† l'import
# peut casser les frameworks de test (pytest) qui remplacent ces streams.
if __name__ == "__main__" and sys.platform == "win32":
    try:
        sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding="utf-8", errors="replace")
        sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding="utf-8", errors="replace")
    except Exception:
        # Si pour une raison quelconque les streams ne sont pas standard
        # (par ex. capture de pytest), ne pas √©chouer √† l'import.
        pass

# Ajouter le r√©pertoire parent au PYTHONPATH pour les imports
sys.path.insert(0, str(Path(__file__).parent))

# Logger global avec loguru
from loguru import logger

from cli import create_context, create_parser
from cli.commands import (
    ActivityCommand,
    AnnouncementCommand,
    AuthCommand,
    CacheCommand,
    CalendarCommand,
    DeviceCommand,
    DNDCommand,
    ListsCommand,
    MultiroomCommand,
    MusicCommand,
    RoutineCommand,
    SmartHomeCommand,
    TimerCommand,
)
from utils.logger import setup_loguru_logger


# Configuration du logging utilisant la fonction centralis√©e
def setup_logging(verbose: bool = False, debug: bool = False, no_color: bool = False):
    """
    Configure le logging am√©lior√© avec loguru via la fonction centralis√©e.

    Args:
        verbose: Mode verbeux (niveau INFO)
        debug: Mode debug (niveau DEBUG)
    """
    # D√©terminer le niveau de log
    if debug:
        level = "DEBUG"
    elif verbose:
        level = "INFO"
    else:
        level = "WARNING"

    # Fichier de log en mode debug
    log_file = None
    if debug:
        log_file = Path("logs") / "alexa_cli.log"

    # Utiliser la fonction centralis√©e du module utils.logger
    # Passer `no_color` uniquement si activ√© pour ne pas modifier la signature
    if no_color:
        setup_loguru_logger(log_file=log_file, level=level, ensure_utf8=True, no_color=True)
    else:
        setup_loguru_logger(log_file=log_file, level=level, ensure_utf8=True)


def register_all_commands(parser: Any) -> None:
    """
    Enregistre toutes les commandes disponibles.

    Args:
        parser: CommandParser
    """
    # Phase 1 - Sprint 1 ‚úÖ
    parser.register_command("auth", AuthCommand)
    parser.register_command("device", DeviceCommand)

    # Phase 2 - Sprint 2 ‚úÖ
    parser.register_command("music", MusicCommand)
    parser.register_command("timers", TimerCommand)
    # alarm et reminder sont maintenant des sous-cat√©gories de timers

    # Phase 3 - Sprint 3 ‚úÖ
    parser.register_command("smarthome", SmartHomeCommand)

    # Phase 4 - Sprint 4 ‚úÖ
    parser.register_command("announcement", AnnouncementCommand)
    parser.register_command("dnd", DNDCommand)
    # announcement: SUPPRIM√â - Drop-in bloqu√© par Amazon (privacy)

    # Phase 5 - Sprint 5 ‚úÖ
    parser.register_command("activity", ActivityCommand)
    parser.register_command("calendar", CalendarCommand)
    parser.register_command("lists", ListsCommand)

    # Phase 6 - Sprint 6 ‚úÖ
    parser.register_command("routine", RoutineCommand)
    parser.register_command("multiroom", MultiroomCommand)

    # Cache management
    parser.register_command("cache", CacheCommand)


def main() -> int:
    """
    Point d'entr√©e principal de la CLI.

    Returns:
        Code de sortie (0 = succ√®s, >0 = erreur)
    """
    try:
        # Configuration temporaire du logging (tr√®s silencieux)
        logger.remove()
        logger.add(sys.stdout, level="CRITICAL", format="{message}")  # Seulement CRITICAL

        # Cr√©er le parser
        parser = create_parser(version="2.0.0")

        # Enregistrer toutes les commandes
        register_all_commands(parser)

        # Parser les arguments
        # Si -h est pass√© apr√®s une action, c'est une erreur car -h n'existe qu'au niveau cat√©gorie
        if "-h" in sys.argv and len(sys.argv) > 3:
            # Il y a au moins: script, category, action, -h
            # V√©rifier si -h vient apr√®s une action (position 3+)
            if sys.argv[-1] == "-h" or (len(sys.argv) > 3 and "-h" in sys.argv[3:]):
                # Sauvegarder les arguments originaux
                original_argv = sys.argv.copy()

                # Afficher l'erreur explicite que -h n'est pas support√© au niveau action
                print("alexa: error: unrecognized arguments: -h")
                print()
                print("üí° L'option -h n'est disponible qu'au niveau de la cat√©gorie, pas au niveau de l'action")
                print()

                # Afficher l'aide de la cat√©gorie
                sys.argv = [original_argv[0], original_argv[1], "-h"]
                args = parser.parse_args()
                sys.exit(0)

        args = parser.parse_args()

        # Configurer le logging d√©finitif avec les bonnes options
        verbose_mode = getattr(args, "verbose", False)
        debug_mode = getattr(args, "debug", False)
        # Only pass --no-color when the attribute is present on args
        no_color_exists = hasattr(args, "no_color")
        raw_no_color = getattr(args, "no_color", False)
        # If argparse produced a real bool, keep it. If tests used MagicMock, coerce to False.
        no_color_mode = raw_no_color if isinstance(raw_no_color, bool) else False

        # D√©terminer le niveau de log (conserv√© pour compatibilit√©)
        if debug_mode:
            level = "DEBUG"
        elif verbose_mode:
            level = "INFO"
        else:
            level = "WARNING"

        # Setup logger once, respecting --no-color
        # Call the module-level helper so tests can patch it
        if isinstance(raw_no_color, bool):
            # pass only when it's a real bool (i.e. user provided the flag)
            setup_logging(verbose=verbose_mode, debug=debug_mode, no_color=no_color_mode)
        else:
            setup_logging(verbose=verbose_mode, debug=debug_mode)

        logger.info(f"Alexa Voice Control CLI v2.0.0 - Cat√©gorie: {args.category}")

        # Cr√©er le contexte
        config_file = args.config if hasattr(args, "config") and args.config else None
        context = create_context(config_file=config_file)

        # Charger l'authentification (sauf pour auth login)
        # Si les cookies existent, initialiser l'auth dans le contexte
        if not (args.category == "auth" and args.action == "login"):
            try:
                from alexa_auth.alexa_auth import AlexaAuth
                from core.state_machine import ConnectionState

                # Charger l'authentification avec cache
                auth = AlexaAuth(cache_service=context.cache_service)
                if auth.load_cookies():
                    # Sanity check: tenter un ping minimal sur un endpoint devices
                    try:
                        resp = auth.get(f"https://alexa.{auth.amazon_domain}/api/devices-v2/device", timeout=10)
                        if getattr(resp, "status_code", None) == 200:
                            # Cookies et endpoint valides
                            context.state_machine.set_initial_state(ConnectionState.AUTHENTICATED)
                            context.initialize_auth(auth)
                            logger.debug(f"Authentification charg√©e: {auth.get_cookie_info()}")
                        else:
                            logger.warning(
                                f"Cookies pr√©sents mais ping API a renvoy√© {getattr(resp, 'status_code', 'unknown')}. Ne pas d√©finir comme authentifi√©"
                            )
                    except Exception as e:
                        logger.warning(f"Cookies charg√©s mais v√©rification API √©chou√©e: {e}")
                else:
                    logger.debug("Pas de cookies valides trouv√©s")
            except Exception as e:
                logger.debug(f"Impossible de charger l'auth: {e}")

        # R√©cup√©rer la classe de commande
        command_class = parser.get_command_class(args.category)

        if not command_class:
            if not args.category:
                logger.error("Aucune cat√©gorie sp√©cifi√©e")
                print("‚ùå Erreur: Veuillez sp√©cifier une cat√©gorie (ex: alexa device list)", file=sys.stderr)
            else:
                logger.error(f"Commande '{args.category}' non trouv√©e")
                print(f"‚ùå Erreur: Cat√©gorie '{args.category}' non reconnue", file=sys.stderr)
            return 1

        # Cr√©er l'instance de commande avec le contexte
        command = command_class(context)

        # Ex√©cuter la commande
        success = command.execute(args)

        # Nettoyer le contexte
        context.cleanup()

        # Retourner le code de sortie
        return 0 if success else 1

    except KeyboardInterrupt:
        print("\n‚ö†Ô∏è  Interruption par l'utilisateur", file=sys.stderr)
        logger.warning("Interruption par Ctrl+C")
        return 130

    except Exception as e:
        logger.exception("Erreur non g√©r√©e dans main()")
        print(f"‚ùå Erreur inattendue: {e}", file=sys.stderr)
        return 1


if __name__ == "__main__":
    sys.exit(main())
