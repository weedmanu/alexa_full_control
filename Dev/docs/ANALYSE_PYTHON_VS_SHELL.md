# üîç Analyse Comparative: Python CLI vs Script Shell

**Date**: 8 octobre 2025  
**Objectif**: Rendre le CLI Python aussi performant et complet que le script shell

---

## üìä R√©sum√© Ex√©cutif

| Aspect                 | Script Shell (.sh)    | CLI Python            | Gap                  |
| ---------------------- | --------------------- | --------------------- | -------------------- |
| **Authentification**   | ‚úÖ Refresh Token      | ‚úÖ Refresh Token      | ‚úÖ √âquivalent        |
| **Liste Appareils**    | ‚úÖ Complet            | ‚úÖ Complet            | ‚úÖ √âquivalent        |
| **Contr√¥les Musique**  | ‚úÖ Fonctionnel        | ‚úÖ Fonctionnel        | ‚úÖ √âquivalent        |
| **√âtat Player**        | ‚úÖ **D√âTAILL√â**       | ‚ùå **403 Forbidden**  | ‚ö†Ô∏è **CRITIQUE**      |
| **Queue/File**         | ‚úÖ **D√âTAILL√âE**      | ‚ùå **Non impl√©ment√©** | ‚ö†Ô∏è **CRITIQUE**      |
| **Informations Media** | ‚úÖ **JSON complet**   | ‚ùå **Limit√©**         | ‚ö†Ô∏è **IMPORTANT**     |
| **Volume**             | ‚úÖ Cache local        | ‚úÖ API directe        | ‚úÖ √âquivalent        |
| **TTS/Speak**          | ‚úÖ S√©quences          | ‚úÖ VoiceCommand       | ‚úÖ √âquivalent        |
| **Multiroom**          | ‚úÖ Cr√©er/Supprimer    | ‚ö†Ô∏è Manager manquant   | ‚ùå **√Ä IMPL√âMENTER** |
| **Bluetooth**          | ‚úÖ Connect/Disconnect | ‚ùå Non impl√©ment√©     | ‚ùå **√Ä IMPL√âMENTER** |

---

## üéØ PROBL√àME CRITIQUE #1: √âtat du Player

### ‚ùå Situation Actuelle (Python)

```python
# core/music/playback_manager.py:218
def get_state(self, device_serial: str, device_type: str) -> Optional[Dict]:
    """R√©cup√®re l'√©tat actuel de la lecture.

    Note: L'endpoint /api/np/player retourne 403 Forbidden.
    Cette fonctionnalit√© n'est pas disponible via l'API Amazon.
    """
    logger.warning("get_state() appel√© mais /api/np/player retourne 403 Forbidden")
    return None
```

**R√©sultat CLI Python**:

```bash
$ ./alexa music status -d "Salon Echo"
‚ö†Ô∏è  L'√©tat de la lecture n'est pas disponible via l'API Amazon
üí° Les contr√¥les musicaux (play/pause/next/stop) fonctionnent correctement
```

### ‚úÖ Situation Script Shell

```bash
# scripts/alexa_remote_control.sh:870
show_queue()
{
  ${CURL} ${OPTS} -s -b ${COOKIE} -A "${BROWSER}" \
   -H "csrf: $(awk "\$0 ~/.${AMAZON}.*csrf[ \\s\\t]+/ {print \$7}" ${COOKIE})" \
   -X GET \
   "https://${ALEXA}/api/np/player?deviceSerialNumber=${DEVICESERIALNUMBER}&deviceType=${DEVICETYPE}${PARENT}"
}
```

**R√©sultat Script Shell**:

```json
{
  "playerInfo": {
    "infoText": {
      "subText1": "Mazzy Star",
      "subText2": "So Tonight That I Might See",
      "title": "Fade Into You"
    },
    "progress": {
      "mediaLength": 296,
      "mediaProgress": 194
    },
    "state": "PLAYING",
    "volume": {
      "muted": false,
      "volume": 50
    },
    "quality": {
      "codec": "flac",
      "dataRateInBitsPerSecond": 1681132,
      "samplingRateInHertz": 44100
    }
  }
}
```

### üîß SOLUTION

**Le probl√®me n'est PAS l'API, c'est l'impl√©mentation Python !**

Le script shell **FONCTIONNE** avec le m√™me endpoint `/api/np/player`. Voici ce qui manque:

#### 1. **Headers Manquants**

```python
# ‚ùå Actuel (Python)
headers={"csrf": self.auth.csrf}

# ‚úÖ N√©cessaire (comme le shell)
headers={
    "csrf": self.auth.csrf,
    "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:1.0) bash-script/1.0",
    "DNT": "1",
    "Connection": "keep-alive",
    "Referer": f"https://{self.config.alexa_domain}/spa/index.html",
    "Origin": f"https://{self.config.alexa_domain}",
    "Accept": "application/json",
    "Accept-Language": "fr-FR,fr;q=0.9"
}
```

#### 2. **Param√®tre PARENT manquant**

```python
# Le script shell ajoute les infos du parent multiroom si n√©cessaire
PARENT=""
PARENTID=$(jq '.devices[] | select(.accountName == $device) | .parentClusters[0]')
if [ "$PARENTID" != "null" ] ; then
    PARENT="&lemurId=${PARENTID}&lemurDeviceType=${PARENTDEVICE}"
fi

# URL compl√®te:
# /api/np/player?deviceSerialNumber=XXX&deviceType=YYY&lemurId=ZZZ&lemurDeviceType=AAA
```

#### 3. **Endpoints Multiples**

Le script shell interroge **3 endpoints** pour avoir les infos compl√®tes:

```bash
# 1. √âtat du player
GET /api/np/player?deviceSerialNumber=X&deviceType=Y

# 2. √âtat m√©dia
GET /api/media/state?deviceSerialNumber=X&deviceType=Y

# 3. Queue compl√®te
GET /api/np/queue?deviceSerialNumber=X&deviceType=Y
```

---

## üéØ PROBL√àME CRITIQUE #2: File d'Attente (Queue)

### ‚ùå Actuel Python

```python
# core/music/playback_manager.py:49
def get_queue(self, device_serial: str, device_type: str) -> Optional[Dict]:
    """R√©cup√®re la file d'attente de lecture."""
    response = self.auth.session.get(
        f"https://{self.config.alexa_domain}/api/np/queue",
        params={"deviceSerialNumber": device_serial, "deviceType": device_type},
        headers={"csrf": self.auth.csrf},
    )
    return response.json()
```

**R√©sultat**: Fonction existe mais **jamais expos√©e dans le CLI** !

### ‚úÖ Script Shell

Retourne la **queue compl√®te** avec 5 morceaux suivants, artwork, artistes, etc.

### üîß SOLUTION

1. **Ajouter l'action `queue` au CLI**:

```python
# cli/commands/music.py
queue_parser = subparsers.add_parser("queue", help="Afficher la file d'attente")
queue_parser.add_argument("-d", "--device", required=True)
```

2. **Am√©liorer les headers** (m√™me probl√®me que get_state)

---

## üéØ PROBL√àME #3: Multiroom Manager Manquant

### ‚ùå Actuel Python

```python
# cli/commands/multiroom.py:149
if not self.context.multiroom_mgr:
    self.error("MultiroomManager non disponible")
    return False
```

**Erreur**:

```
AttributeError: 'Context' object has no attribute 'multiroom_mgr'
```

### ‚úÖ Script Shell

```bash
# Supprimer multiroom
delete_multiroom() {
  curl -X DELETE "https://${ALEXA}/api/lemur/tail/${DEVICESERIALNUMBER}"
}

# Cr√©er multiroom
create_multiroom() {
  JSON='{"id":null,"name":"'${LEMUR}'","members":['${DEVICES}']}'
  curl -X POST -d "${JSON}" "https://${ALEXA}/api/lemur/tail"
}
```

### üîß SOLUTION

Cr√©er `/home/manu/Documents/GitHub/alexa_advanced_control-dev-cli/core/multiroom_manager.py`:

```python
class MultiroomManager:
    """Gestionnaire des groupes multiroom (multi-pi√®ces)."""

    def get_groups(self) -> List[Dict]:
        """Liste tous les groupes multiroom."""
        # Filtrer devices avec deviceFamily == "WHA"

    def create_group(self, name: str, device_serials: List[str], primary_serial: str) -> bool:
        """Cr√©e un groupe multiroom."""
        # POST /api/lemur/tail

    def delete_group(self, group_serial: str) -> bool:
        """Supprime un groupe multiroom."""
        # DELETE /api/lemur/tail/{serial}
```

Et l'ajouter au contexte:

```python
# cli/context.py
@property
def multiroom_mgr(self):
    if self._multiroom_mgr is None and self.auth:
        from core.multiroom_manager import MultiroomManager
        self._multiroom_mgr = MultiroomManager(self.auth, self.state_machine)
    return self._multiroom_mgr
```

---

## üéØ PROBL√àME #4: Bluetooth Non Impl√©ment√©

### ‚ùå Actuel Python

Aucune commande Bluetooth !

### ‚úÖ Script Shell

```bash
# Lister appareils BT
list_bluetooth() {
  curl "https://${ALEXA}/api/bluetooth?cached=false"
}

# Connecter BT
connect_bluetooth() {
  curl -X POST -d '{"bluetoothDeviceAddress":"'${BLUETOOTH}'"}' \
    "https://${ALEXA}/api/bluetooth/pair-sink/${DEVICETYPE}/${DEVICESERIALNUMBER}"
}

# D√©connecter BT
disconnect_bluetooth() {
  curl -X POST \
    "https://${ALEXA}/api/bluetooth/disconnect-sink/${DEVICETYPE}/${DEVICESERIALNUMBER}"
}
```

### üîß SOLUTION

Cr√©er `core/audio/bluetooth_manager.py` (d√©j√† existe mais incomplet).

---

## üìã Plan d'Action Prioris√©

### üî¥ PRIORIT√â CRITIQUE (Bloquer 100% audit)

1. **Corriger get_state() pour qu'il fonctionne** ‚è±Ô∏è 30 min

   - Ajouter tous les headers du script shell
   - G√©rer le param√®tre PARENT (lemurId)
   - Tester sur "Salon Echo"

2. **Exposer la queue dans le CLI** ‚è±Ô∏è 20 min
   - Ajouter action `queue` √† `music.py`
   - Afficher les 5 prochains morceaux
   - Format JSON + Format texte

### üü† PRIORIT√â HAUTE (Compl√©ter les fonctionnalit√©s)

3. **Impl√©menter MultiroomManager** ‚è±Ô∏è 1h

   - Cr√©er le manager
   - L'ajouter au Context
   - Tester create/delete/list

4. **Compl√©ter BluetoothManager** ‚è±Ô∏è 45 min
   - Impl√©menter list/connect/disconnect
   - Ajouter commandes CLI

### üü° PRIORIT√â MOYENNE (Am√©liorer l'UX)

5. **Am√©liorer affichage status musique** ‚è±Ô∏è 30 min

   - Afficher artwork (URL)
   - Afficher progression (3:14 / 4:56)
   - Afficher qualit√© audio (FLAC, bitrate)
   - Afficher provider (Amazon Music, Spotify)

6. **Ajouter cache volume local** ‚è±Ô∏è 20 min
   - Comme le script shell (`/tmp/.alexa.volume.*`)
   - √âviter requ√™tes API r√©p√©t√©es

---

## üõ†Ô∏è Modifications Imm√©diates Recommand√©es

### Fichier 1: `core/music/playback_manager.py`

```python
def get_state(self, device_serial: str, device_type: str, parent_id: str = None, parent_type: str = None) -> Optional[Dict]:
    """R√©cup√®re l'√©tat complet de la lecture (comme le script shell)."""
    with self._lock:
        if not self.state_machine.can_execute_commands:
            return None

        try:
            # Construire params comme le script shell
            params = {
                "deviceSerialNumber": device_serial,
                "deviceType": device_type
            }

            # Ajouter parent si multiroom
            if parent_id:
                params["lemurId"] = parent_id
                params["lemurDeviceType"] = parent_type

            # Headers complets comme le script shell
            headers = {
                "csrf": self.auth.csrf,
                "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:1.0) bash-script/1.0",
                "DNT": "1",
                "Connection": "keep-alive",
                "Referer": f"https://{self.config.alexa_domain}/spa/index.html",
                "Origin": f"https://{self.config.alexa_domain}",
                "Content-Type": "application/json; charset=UTF-8"
            }

            # 1. √âtat du player
            player_response = self.breaker.call(
                self.auth.session.get,
                f"https://{self.config.alexa_domain}/api/np/player",
                params=params,
                headers=headers,
                timeout=10
            )
            player_response.raise_for_status()

            # 2. √âtat m√©dia
            media_response = self.breaker.call(
                self.auth.session.get,
                f"https://{self.config.alexa_domain}/api/media/state",
                params={"deviceSerialNumber": device_serial, "deviceType": device_type},
                headers=headers,
                timeout=10
            )
            media_response.raise_for_status()

            # 3. Queue
            queue_response = self.breaker.call(
                self.auth.session.get,
                f"https://{self.config.alexa_domain}/api/np/queue",
                params={"deviceSerialNumber": device_serial, "deviceType": device_type},
                headers=headers,
                timeout=10
            )
            queue_response.raise_for_status()

            # Combiner les 3 r√©ponses
            return {
                "player": player_response.json(),
                "media": media_response.json(),
                "queue": queue_response.json()
            }

        except Exception as e:
            logger.error(f"Erreur r√©cup√©ration √©tat: {e}")
            return None
```

### Fichier 2: `cli/commands/music.py`

Ajouter apr√®s le parser "status":

```python
# Action: queue
queue_parser = subparsers.add_parser(
    "queue",
    help="Afficher la file d'attente",
    description="Affiche la liste des morceaux en attente de lecture."
)
queue_parser.add_argument(
    "-d", "--device",
    type=str,
    required=True,
    metavar="DEVICE_NAME",
    help="Nom de l'appareil cible"
)
```

Et impl√©menter:

```python
def _show_queue(self, args: argparse.Namespace) -> bool:
    """Afficher la file d'attente (comme le script shell)."""
    try:
        serial = self.get_device_serial(args.device)
        if not serial:
            return False

        device_type = self._get_device_type(args.device)

        # R√©cup√©rer √©tat complet
        state = self.call_with_breaker(
            self.context.playback_mgr.get_state,
            serial,
            device_type
        )

        if not state:
            self.warning("Impossible de r√©cup√©rer la queue")
            return False

        # Afficher comme le script shell
        if hasattr(args, "json_output") and args.json_output:
            print(json.dumps(state, indent=2, ensure_ascii=False))
        else:
            self._display_complete_queue(state)

        return True

    except Exception as e:
        self.logger.exception("Erreur affichage queue")
        self.error(f"Erreur: {e}")
        return False

def _display_complete_queue(self, state: Dict) -> None:
    """Affiche la queue comme le script shell."""
    player = state.get("player", {}).get("playerInfo", {})
    queue = state.get("queue", {}).get("queueInfo", {}).get("media", [])

    # Morceau en cours
    if player:
        info = player.get("infoText", {})
        progress = player.get("progress", {})
        quality = player.get("quality", {})

        print("\nüéµ En cours de lecture:\n")
        print(f"  Titre: {info.get('title', 'N/A')}")
        print(f"  Artiste: {info.get('subText1', 'N/A')}")
        print(f"  Album: {info.get('subText2', 'N/A')}")

        if progress:
            current = progress.get("mediaProgress", 0)
            total = progress.get("mediaLength", 0)
            print(f"  Progression: {current//60}:{current%60:02d} / {total//60}:{total%60:02d}")

        if quality:
            codec = quality.get("stats", {}).get("codec", "N/A")
            bitrate = quality.get("stats", {}).get("dataRateInBitsPerSecond", 0)
            samplerate = quality.get("stats", {}).get("samplingRateInHertz", 0)
            print(f"  Qualit√©: {codec.upper()} {samplerate//1000}kHz {bitrate//1000}kbps")

    # Prochains morceaux
    if queue:
        print(f"\nüìã File d'attente ({len(queue)} morceaux):\n")
        for i, track in enumerate(queue[:5], 1):
            info = track.get("infoText", {})
            print(f"  {i}. {info.get('title', 'N/A')} - {info.get('subText1', 'N/A')}")
```

---

## üéØ R√©sultat Attendu

Apr√®s ces modifications, le CLI Python devrait donner **EXACTEMENT** le m√™me r√©sultat que le script shell:

```bash
$ ./alexa music status -d "Salon Echo"

üéµ En cours de lecture:

  Titre: Fade Into You
  Artiste: Mazzy Star
  Album: So Tonight That I Might See
  Progression: 3:14 / 4:56
  Qualit√©: FLAC 44kHz 1681kbps

üìã File d'attente (5 morceaux):

  1. Fade Into You - Mazzy Star
  2. misses - Dominic Fike
  3. Trouble - Cage The Elephant
  4. How Soon Is Now? - The Smiths
  5. Lovers Rock - TV Girl
```

---

## üìä Conclusion

**Le script shell fonctionne PARFAITEMENT car il:**

1. ‚úÖ Utilise les **bons headers HTTP**
2. ‚úÖ G√®re les **appareils multiroom** (PARENT)
3. ‚úÖ Interroge **plusieurs endpoints** pour avoir toutes les infos
4. ‚úÖ Impl√©mente **toutes les fonctionnalit√©s** (BT, multiroom, queue)

**Le CLI Python doit simplement:**

1. üîß **Copier les headers du script shell**
2. üîß **G√©rer les parents multiroom**
3. üîß **Combiner les 3 endpoints** (player, media, queue)
4. üîß **Impl√©menter les managers manquants** (multiroom, bluetooth)

**Temps estim√© total**: **~4 heures** pour avoir un CLI Python au niveau du script shell.

---

_Document g√©n√©r√© le 8 octobre 2025 - Analyse comparative compl√®te_
