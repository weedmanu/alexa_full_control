# üìã TODO - Am√©liorations du Projet Alexa Full Control

**Date:** 16 octobre 2025  
**Branche:** refacto  
**Status:** üü¢ Code Quality Pass - Pr√™t pour am√©liorations architecturales

---

## üéØ Analyse Globale

### √âtat Actuel ‚úÖ

- **Code Quality:** 100% Pass (Black, isort, Ruff, Flake8)
- **Architecture:** Refactoris√©e (BaseManager elimin√© 650+ lignes code dupliqu√©)
- **Thread-Safety:** Compl√®te (RLock, √©tat machine)
- **Caching:** 2-niveaux (m√©moire + disque via CacheService)

### Opportunit√©s d'Am√©lioration üöÄ

1. **Redondance de Code:** Plusieurs managers non-BaseManager
2. **Inconsistance API:** M√©langes auth/http_client dans constructeurs
3. **S√©curit√©:** Headers CSRF dupliqu√©s, gestion tokens
4. **Factorisation:** Patterns r√©p√©t√©s dans CLI commands
5. **Distribution:** Tous managers cr√©ent leurs propres CircuitBreaker
6. **Configuration:** Config √©parpill√©e, pas de validation centralis√©e

---

## üìë Table des Mati√®res

- [1. REDONDANCE & FACTORISATION](#1-redondance--factorisation)
- [2. ARCHITECTURE & DESIGN PATTERNS](#2-architecture--design-patterns)
- [3. S√âCURIT√â](#3-s√©curit√©)
- [4. PERFORMANCE](#4-performance)
- [5. DISTRIBUTION & INITIALISATION](#5-distribution--initialisation)
- [6. INT√âGRATION CLI](#6-int√©gration-cli)
- [7. TESTS & VALIDATION](#7-tests--validation)
- [8. DOCUMENTATION](#8-documentation)

---

## 1. REDONDANCE & FACTORISATION

### 1.1 Merger Managers non-BaseManager dans BaseManager

**Impact:** üî¥ **CRITIQUE** | **Effort:** üü° **MOYEN** (2-3 jours)

**Probl√®me:**

```
‚úó RoutineManager: Duplicate circuit_breaker, cache_ttl, _lock, _api_call logic
‚úó PlaybackManager: Duplicate state_machine, lock, headers construction
‚úó TuneInManager: Duplicate http_client normalization logic
‚úó LibraryManager: Duplicate cache logic
‚úó ListsManager: Duplicate lock + state_machine check
```

**Managers √† refactoriser (8 total):**

- `core/routines/routine_manager.py` - **~200 lignes** duplicates
- `core/music/playback_manager.py` - **~150 lignes** duplicates
- `core/music/tunein_manager.py` - **~80 lignes** duplicates
- `core/music/library_manager.py` - **~70 lignes** duplicates
- `core/lists/lists_manager.py` - **~60 lignes** duplicates
- `core/audio/bluetooth_manager.py` - **~50 lignes** duplicates
- `core/audio/equalizer_manager.py` - **~50 lignes** duplicates
- `core/settings/device_settings_manager.py` - **~60 lignes** duplicates

**Cible:** R√©duire de **~560 lignes** code dupliqu√©

**Action:**

```python
# AVANT (8 managers)
class RoutineManager:
    def __init__(self, auth, config, state_machine=None, cache_service=None):
        self.breaker = CircuitBreaker(...)  # DUPLI
        self._lock = threading.RLock()      # DUPLI
        self.cache_service = cache_service or CacheService()  # DUPLI
        self._cache_ttl = 300               # DUPLI

# APR√àS (h√©rite BaseManager)
class RoutineManager(BaseManager[Dict[str, Any]]):
    def __init__(self, auth, config, state_machine=None, cache_service=None):
        super().__init__(
            http_client=create_http_client_from_auth(auth),
            config=config,
            state_machine=state_machine,
            cache_service=cache_service
        )
        # ‚úÖ H√©rite: breaker, _lock, cache_service, _api_call, headers, etc.
```

**Files √† modifier:**

- [ ] `core/routines/routine_manager.py` - H√©riter BaseManager
- [ ] `core/music/playback_manager.py` - H√©riter BaseManager
- [ ] `core/music/tunein_manager.py` - H√©riter BaseManager
- [ ] `core/music/library_manager.py` - H√©riter BaseManager
- [ ] `core/lists/lists_manager.py` - H√©riter BaseManager
- [ ] `core/audio/bluetooth_manager.py` - H√©riter BaseManager
- [ ] `core/audio/equalizer_manager.py` - H√©riter BaseManager
- [ ] `core/settings/device_settings_manager.py` - H√©riter BaseManager

**Tests √† ajouter:**

- [ ] `Dev/pytests/test_all_managers_inherit_base.py` - V√©rifier tous managers h√©ritent BaseManager
- [ ] Validation API calls uniformes

---

### 1.2 Centraliser Gestion CircuitBreaker

**Impact:** üü° **MOYEN** | **Effort:** üü° **MOYEN** (1-2 jours)

**Probl√®me:**

```
Actuellement (33 instances CircuitBreaker distribu√©es):
- 15 instances dans core/managers
- 8 instances dans core/audio
- 5 instances dans core/music
- 5 instances autres

‚ö†Ô∏è Configuration incoh√©rente:
  - DeviceManager: failure_threshold=3, timeout=30
  - AlarmManager: failure_threshold=2, timeout=20
  - PlaybackManager: failure_threshold=3, timeout=30
```

**Action:**

```python
# CR√âER: core/breaker_registry.py
class CircuitBreakerRegistry:
    """Registre centralis√© des circuit breakers."""

    _registry = {}

    @classmethod
    def get_or_create(cls, name: str, **kwargs):
        """R√©cup√®re ou cr√©e un breaker singleton."""
        if name not in cls._registry:
            config = cls.get_config(name)
            cls._registry[name] = CircuitBreaker(**config)
        return cls._registry[name]

    @classmethod
    def get_config(cls, name: str) -> Dict:
        """Configuration centralis√©e par manager."""
        configs = {
            "default": {"failure_threshold": 3, "timeout": 30, "recovery_timeout": 60},
            "music": {"failure_threshold": 2, "timeout": 20, "recovery_timeout": 40},
            "device": {"failure_threshold": 4, "timeout": 60, "recovery_timeout": 120},
        }
        return configs.get(name, configs["default"])

# DANS BaseManager
class BaseManager(Generic[T]):
    def __init__(self, ..., breaker_name: str = "default"):
        self.breaker = CircuitBreakerRegistry.get_or_create(breaker_name)
```

**Files √† modifier:**

- [ ] `core/base_manager.py` - Int√©grer registre
- [ ] `core/circuit_breaker.py` - Ajouter registry
- [ ] Tous 33 managers - Utiliser registre au lieu de cr√©er localement

**R√©ductions:**

- Circuit breakers uniques par type: 15 au lieu de 33 (-54% m√©moire)
- Configuration centralis√©e + testable

---

### 1.3 Extraire Patterns CLI R√©p√©titifs

**Impact:** üü° **MOYEN** | **Effort:** üü° **MOYEN** (2-3 jours)

**Probl√®me:**

```
M√™me pattern r√©p√©t√© dans 15+ commands:

def execute(self, args):
    try:
        device_info = self.get_device_info(args.device)
        if not device_info:
            return False

        serial, device_type = device_info

        ctx = getattr(self, "context", None)
        if not ctx or not getattr(ctx, "manager_name", None):
            self.error("Manager non disponible")
            return False

        result = ctx.manager_name.do_something(serial, device_type, args.param)
        # ...
```

**Action:** Cr√©er `CommandTemplate` base class

```python
# CR√âER: cli/command_template.py
class ManagerCommand(BaseCommand):
    """Template pour commandes utilisant managers."""

    manager_attr: str  # Ex: "device_mgr", "playback_mgr"

    def get_manager(self):
        """R√©cup√®re manager du contexte avec v√©rification."""
        ctx = getattr(self, "context", None)
        if not ctx:
            self.error("Contexte non disponible")
            return None

        manager = getattr(ctx, self.manager_attr, None)
        if not manager:
            self.error(f"{self.manager_attr} non disponible")
            return None
        return manager

    def execute_manager_action(
        self,
        manager_method: Callable,
        args: argparse.Namespace,
        action_name: str
    ) -> bool:
        """Ex√©cute une action manager de fa√ßon uniforme."""
        try:
            device_info = self.get_device_info(args.device)
            if not device_info:
                return False

            serial, device_type = device_info
            manager = self.get_manager()
            if not manager:
                return False

            result = manager_method(serial, device_type, *self.get_method_args(args))

            if result:
                self.success(f"‚úÖ {action_name} r√©ussi")
            else:
                self.error(f"‚ùå {action_name} √©chou√©")
            return result
        except Exception as e:
            self.error(f"Erreur {action_name}: {e}")
            return False

    def get_method_args(self, args: argparse.Namespace) -> List[Any]:
        """√Ä surcharger: retourner args additionnels pour la m√©thode."""
        return []

# UTILISATION
class PlayCommand(ManagerCommand):
    manager_attr = "playback_mgr"

    def execute(self, args):
        return self.execute_manager_action(
            self.get_manager().play,
            args,
            "Lecture"
        )
```

**Files √† cr√©er/modifier:**

- [ ] `cli/command_template.py` - Cr√©er ManagerCommand base class
- [ ] `cli/commands/music/playback.py` - Refactoriser 8+ commands
- [ ] `cli/commands/device.py` - Refactoriser 5+ commands
- [ ] `cli/commands/alarm.py` - Refactoriser 4+ commands

**Impact:** R√©duction **~300 lignes** code CLI dupliqu√©

---

## 2. ARCHITECTURE & DESIGN PATTERNS

### 2.1 Normaliser Initialisation Managers

**Impact:** üü¢ **BAS** | **Effort:** üü° **MOYEN** (1-2 jours)

**Probl√®me:**

```python
# INCOH√âRENT - 3 patterns diff√©rents

# Pattern 1: auth + config
DeviceManager(auth, config, state_machine)

# Pattern 2: auth_or_http + config (PlaybackManager)
PlaybackManager(auth_or_http, config, state_machine)

# Pattern 3: Pas de state_machine par d√©faut
TuneInManager(auth_or_http, config, state_machine=None)

# Pattern 4: Lazy state_machine creation
class RoutineManager:
    def __init__(self, auth, config, state_machine=None):
        self.state_machine = state_machine or AlexaStateMachine()  # Lazy
```

**Solution - Factory Pattern:**

```python
# CR√âER: core/manager_factory.py
from dataclasses import dataclass
from typing import Type, TypeVar

@dataclass
class ManagerConfig:
    """Configuration centralis√©e pour tous les managers."""
    auth: Any
    config: Any
    state_machine: Optional[AlexaStateMachine] = None
    cache_service: Optional[CacheService] = None
    cache_ttl: int = 300
    breaker_name: str = "default"

    def __post_init__(self):
        """Valide et initialise les d√©pendances defaults."""
        if not self.state_machine:
            self.state_machine = AlexaStateMachine()
        if not self.cache_service:
            self.cache_service = CacheService()

class ManagerFactory:
    """Factory pour cr√©er managers de fa√ßon uniforme."""

    _config: Optional[ManagerConfig] = None

    @classmethod
    def initialize(cls, config: ManagerConfig):
        """Initialise la configuration globale."""
        cls._config = config

    @classmethod
    def create(cls, manager_class: Type[T], **overrides) -> T:
        """Cr√©e un manager avec configuration."""
        if not cls._config:
            raise RuntimeError("ManagerFactory non initialis√©")

        # Fusionner config globale + overrides
        config = {**dataclasses.asdict(cls._config), **overrides}
        return manager_class(**config)

# UTILISATION
ManagerFactory.initialize(ManagerConfig(
    auth=auth,
    config=config,
    state_machine=state_machine,
    cache_ttl=300
))

device_mgr = ManagerFactory.create(DeviceManager)
playback_mgr = ManagerFactory.create(PlaybackManager, cache_ttl=600)
```

**Files √† cr√©er/modifier:**

- [ ] `core/manager_factory.py` - Cr√©er factory + config
- [ ] `cli/context.py` - Utiliser factory pour initialiser managers
- [ ] Tous managers - Signature uniforme

---

### 2.2 Impl√©menter Repository Pattern pour Cache

**Impact:** üü° **MOYEN** | **Effort:** üî¥ **DIFFICILE** (3-4 jours)

**Probl√®me:**

```python
# Actuellement: Cache m√©lang√© avec logique m√©tier
class DeviceManager(BaseManager):
    def get_devices(self, force_refresh=False):
        with self._lock:
            if self._cache and not force_refresh:
                return self._cache

            # API call + cache update
            response = self._api_call('get', '/api/devices-v2/device')
            devices = response.json() if response else []

            self._cache = devices
            self._cache_timestamp = time.time()
            return devices
```

**Solution - Repository Pattern:**

```python
# CR√âER: core/repositories/base_repository.py
class Repository(Generic[T]):
    """Pattern Repository avec abstraction cache."""

    def __init__(self, cache_service: CacheService, cache_ttl: int = 300):
        self.cache = cache_service
        self.cache_ttl = cache_ttl

    async def get(self, key: str, force_refresh=False) -> Optional[T]:
        """R√©cup√®re avec cache multi-niveaux."""
        if not force_refresh:
            # Cache m√©moire
            cached = self._memory_cache.get(key)
            if cached:
                return cached

            # Cache disque
            cached = self.cache.get(key)
            if cached:
                self._memory_cache[key] = cached
                return cached

        # R√©cup√®re depuis source
        data = await self._fetch_source(key)
        if data:
            self.cache.set(key, data, ttl_seconds=self.cache_ttl)
            self._memory_cache[key] = data

        return data

    async def _fetch_source(self, key: str) -> Optional[T]:
        """√Ä surcharger: r√©cup√®re depuis API/DB/etc."""
        raise NotImplementedError

# CR√âER: core/repositories/device_repository.py
class DeviceRepository(Repository[Dict[str, Any]]):
    """Repository pour appareils."""

    def __init__(self, http_client: HTTPClientProtocol, config, cache_service):
        super().__init__(cache_service, cache_ttl=300)
        self.http_client = http_client
        self.config = config

    async def _fetch_source(self, key: str):
        """R√©cup√®re appareils depuis API."""
        response = self.http_client.get(
            f"https://{self.config.alexa_domain}/api/devices-v2/device"
        )
        response.raise_for_status()
        return response.json()

# UTILISATION
class DeviceManager(BaseManager):
    def __init__(self, ...):
        super().__init__(...)
        self.repository = DeviceRepository(
            self.http_client,
            self.config,
            self.cache_service
        )

    def get_devices(self, force_refresh=False):
        """Simplifi√© - logique m√©tier s√©par√©e du cache."""
        return self.repository.get("devices", force_refresh)
```

**B√©n√©fices:**

- S√©paration concerns (m√©tier vs cache)
- Cache logic testable ind√©pendamment
- R√©utilisable dans services, CLI, API

**Files √† cr√©er:**

- [ ] `core/repositories/__init__.py`
- [ ] `core/repositories/base_repository.py` - Repository g√©n√©rique
- [ ] `core/repositories/device_repository.py`
- [ ] `core/repositories/alarm_repository.py`
- [ ] `core/repositories/timer_repository.py`
- [ ] `core/repositories/routine_repository.py`
- [ ] (+ 8 autres pour music, audio, etc.)

**Tests:**

- [ ] `Dev/pytests/test_repository_pattern.py`

---

## 3. S√âCURIT√â

### 3.1 Centraliser Gestion CSRF Tokens

**Impact:** üü° **MOYEN** | **Effort:** üü° **MOYEN** (2 jours)

**Probl√®me:**

```python
# DUPLIQU√â dans 50+ endroits:
headers = {
    "csrf": getattr(self.http_client, "csrf", getattr(self.auth, "csrf", ""))
}

# RISQUES:
‚úó Pas de validation CSRF (accepte strings vides)
‚úó Fallback implicite (auth vs http_client) - confus
‚úó Pas de refresh CSRF apr√®s expiration
‚úó Hardcod√© partout
```

**Solution - Secure Headers Manager:**

```python
# CR√âER: core/security/csrf_manager.py
class CSRFManager:
    """Gestion centralis√©e CSRF tokens."""

    def __init__(self, auth: AlexaAuth):
        self.auth = auth
        self._csrf_cache = None
        self._csrf_timestamp = 0
        self._lock = threading.RLock()

    def get_csrf(self, validate=True) -> str:
        """R√©cup√®re CSRF token avec validation."""
        with self._lock:
            # Refresh si expir√© (30 min)
            if self._should_refresh_csrf():
                self._refresh_csrf_from_auth()

            csrf = self._csrf_cache or ""

            if validate and not self._is_valid_csrf(csrf):
                raise SecurityError(f"CSRF token invalide: {csrf[:10]}...")

            return csrf

    def _should_refresh_csrf(self) -> bool:
        """V√©rifie si refresh CSRF n√©cessaire."""
        return (time.time() - self._csrf_timestamp) > 1800  # 30 min

    def _is_valid_csrf(self, csrf: str) -> bool:
        """Valide format CSRF (pas vide, format Amazon)."""
        if not csrf or len(csrf) < 10:
            return False
        # Format typique: amzn.xx...
        return csrf.startswith("amzn.") or len(csrf) > 20

    def _refresh_csrf_from_auth(self):
        """R√©cup√®re CSRF depuis auth."""
        csrf = getattr(self.auth, "csrf", None)
        if csrf and self._is_valid_csrf(csrf):
            self._csrf_cache = csrf
            self._csrf_timestamp = time.time()

# CR√âER: core/security/secure_headers.py
class SecureHeadersBuilder:
    """Construit headers s√©curis√©s de fa√ßon uniforme."""

    def __init__(self, config: Any, csrf_mgr: CSRFManager):
        self.config = config
        self.csrf_mgr = csrf_mgr

    def build(self, **extra_headers) -> Dict[str, str]:
        """Construit headers standards + extras."""
        headers = {
            "Content-Type": "application/json; charset=UTF-8",
            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) Alexa-CLI/1.0",
            "Accept": "application/json",
            "Accept-Language": "fr-FR,fr;q=0.9",
            "Referer": f"https://{self.config.alexa_domain}/spa/index.html",
            "Origin": f"https://{self.config.alexa_domain}",
            "DNT": "1",
            "Connection": "keep-alive",
        }

        # CSRF s√©curis√©
        try:
            headers["csrf"] = self.csrf_mgr.get_csrf(validate=True)
        except SecurityError as e:
            logger.error(f"CSRF invalide: {e}")
            raise

        # Merge extras
        headers.update(extra_headers)
        return headers

# DANS BaseManager
class BaseManager:
    def __init__(self, ..., csrf_mgr: Optional[CSRFManager] = None):
        self.csrf_mgr = csrf_mgr or CSRFManager(self.auth)
        self.headers_builder = SecureHeadersBuilder(self.config, self.csrf_mgr)

    def _get_api_headers(self, extra=None):
        """Remplace ancienne logique."""
        return self.headers_builder.build(**(extra or {}))
```

**Files √† cr√©er/modifier:**

- [ ] `core/security/__init__.py`
- [ ] `core/security/csrf_manager.py` - CSRF centralis√©
- [ ] `core/security/secure_headers.py` - Headers s√©curis√©s
- [ ] `core/base_manager.py` - Int√©grer SecureHeadersBuilder
- [ ] Tous managers - Utiliser `_get_api_headers()` uniform√©ment

**Tests de s√©curit√©:**

- [ ] `Dev/pytests/test_csrf_validation.py` - Validation tokens
- [ ] `Dev/pytests/test_headers_security.py` - Headers complets

---

### 3.2 Ajouter Sanitization & Validation Entr√©es

**Impact:** üü° **MOYEN** | **Effort:** üü° **MOYEN** (2-3 jours)

**Probl√®me:**

```python
# ACTUELLEMENT: Pas de validation entr√©es
def create_alarm(self, device_serial: str, alarm_time: str, label: str = ""):
    # device_serial accepte n'importe quoi
    # alarm_time accepte n'importe quoi
    # label aceepte n'importe quoi (injections possibles)

    payload = {"label": label}  # üö® RISQUE INJECTION

def create_reminder(self, ..., text: str):
    payload = {"text": text}  # üö® RISQUE XSS/INJECTION
```

**Solution - Input Validators:**

```python
# CR√âER: core/security/validators.py
class InputValidator:
    """Validation centralis√©e des entr√©es."""

    @staticmethod
    def validate_device_serial(serial: str) -> str:
        """Valide num√©ro de s√©rie appareil."""
        if not serial or not isinstance(serial, str):
            raise ValueError("device_serial doit √™tre string non-vide")
        if len(serial) < 8 or len(serial) > 50:
            raise ValueError(f"device_serial trop court/long: {len(serial)}")
        if not re.match(r'^[A-Z0-9-]+$', serial):
            raise ValueError(f"device_serial invalide: {serial}")
        return serial

    @staticmethod
    def validate_device_type(device_type: str) -> str:
        """Valide type appareil."""
        valid_types = {
            'ALEXA_CURRENT_DEVICE_TYPE',
            'ECHO_DOT', 'ECHO', 'ECHO_PLUS',
            'ECHO_SHOW', 'ECHO_SHOW_5', 'ECHO_SHOW_8',
            'ECHO_SPOT', 'ECHO_AUTO',
            'FIRE_TABLET', 'MOBILE'
        }
        if device_type not in valid_types:
            raise ValueError(f"device_type invalide: {device_type}")
        return device_type

    @staticmethod
    def validate_alarm_time(alarm_time: str) -> str:
        """Valide format temps alarme."""
        try:
            # Format: HH:MM ou ISO 8601
            if ':' in alarm_time:
                h, m = alarm_time.split(':')
                if not (0 <= int(h) <= 23 and 0 <= int(m) <= 59):
                    raise ValueError()
            else:
                datetime.fromisoformat(alarm_time)
            return alarm_time
        except:
            raise ValueError(f"Format time invalide: {alarm_time}")

    @staticmethod
    def sanitize_text(text: str, max_len: int = 500) -> str:
        """Nettoie texte (labels, descriptions, etc.)."""
        if not isinstance(text, str):
            raise ValueError("text doit √™tre string")

        # Limite longueur
        if len(text) > max_len:
            raise ValueError(f"text trop long (max {max_len}): {len(text)}")

        # Enl√®ve caract√®res contr√¥le
        text = ''.join(c for c in text if c.isprintable() or c in '\n\t')

        # √âchappe caract√®res sp√©ciaux pour JSON
        text = text.replace('\\', '\\\\').replace('"', '\\"')

        return text.strip()

# UTILISATION
class AlarmManager(BaseManager):
    def create_alarm(
        self,
        device_serial: str,
        device_type: str,
        alarm_time: str,
        label: str = ""
    ) -> Optional[Dict[str, Any]]:
        # Validation entr√©es
        device_serial = InputValidator.validate_device_serial(device_serial)
        device_type = InputValidator.validate_device_type(device_type)
        alarm_time = InputValidator.validate_alarm_time(alarm_time)
        label = InputValidator.sanitize_text(label, max_len=100) if label else ""

        # Reste du code...
```

**Files √† cr√©er/modifier:**

- [ ] `core/security/validators.py` - Cr√©er InputValidator
- [ ] Tous managers - Ajouter validation entr√©es (20+ m√©thodes)
- [ ] CLI commands - Ajouter validation (`argparse` custom types)

**Tests:**

- [ ] `Dev/pytests/test_input_validation.py`

---

## 4. PERFORMANCE

### 4.1 Impl√©menter Pagination pour API Calls

**Impact:** üü° **MOYEN** | **Effort:** üü° **MOYEN** (1-2 jours)

**Probl√®me:**

```python
# ACTUELLEMENT: R√©cup√®re tout d'un coup
def list_timers(self):
    response = self._api_call('get', '/api/timers')
    return response.json()  # Peut retourner 1000+ items

# üêå LENT si 1000+ timers/alarms/rappels
```

**Solution - Pagination Builder:**

```python
# CR√âER: core/pagination.py
class Pagination:
    """Pagination pour API calls."""

    def __init__(self, page_size: int = 100, max_pages: Optional[int] = None):
        self.page_size = page_size
        self.max_pages = max_pages

    def fetch_all(
        self,
        fetch_func: Callable,
        **kwargs
    ) -> List[Dict[str, Any]]:
        """R√©cup√®re tous les items pagine par page."""
        all_items = []
        page = 0

        while True:
            if self.max_pages and page >= self.max_pages:
                logger.warning(f"Limitation max_pages atteinte: {self.max_pages}")
                break

            # Ajouter pagination params
            params = kwargs.get('params', {})
            params['offset'] = page * self.page_size
            params['limit'] = self.page_size
            kwargs['params'] = params

            response = fetch_func(**kwargs)
            if not response or not response.get('items'):
                break

            items = response['items']
            all_items.extend(items)

            if len(items) < self.page_size:
                break  # Derni√®re page

            page += 1
            logger.debug(f"Fetched page {page}: {len(items)} items")

        return all_items

# UTILISATION
class AlarmManager(BaseManager):
    def list_alarms(self) -> List[Dict[str, Any]]:
        pagination = Pagination(page_size=50, max_pages=10)

        return pagination.fetch_all(
            self._api_call,
            method='get',
            endpoint='/api/alarms'
        )
```

**Files √† cr√©er/modifier:**

- [ ] `core/pagination.py` - Cr√©er Pagination class
- [ ] `core/timers/alarm_manager.py` - Utiliser pagination
- [ ] `core/reminders/reminder_manager.py` - Utiliser pagination
- [ ] `core/alarms/alarm_manager.py` - Utiliser pagination

---

### 4.2 Async/Await pour Parallel API Calls

**Impact:** üî¥ **DIFFICILE** | **Effort:** üî¥ **DIFFICILE** (4-5 jours)

**Probl√®me:**

```python
# ACTUELLEMENT: S√©quentiel
def get_full_state(self, device_serial: str):
    player = self._api_call('get', '/api/np/player', params=...)   # 300ms
    media = self._api_call('get', '/api/media/state', params=...)  # 300ms
    queue = self._api_call('get', '/api/np/queue', params=...)     # 300ms
    # ‚è±Ô∏è Total: ~900ms (s√©quentiel)
```

**Solution - Async Wrapper:**

```python
# CR√âER: core/async_wrapper.py
import asyncio

class AsyncBaseManager(BaseManager):
    """BaseManager avec support async/await."""

    async def _api_call_async(
        self,
        method: str,
        endpoint: str,
        **kwargs
    ) -> Optional[Dict[str, Any]]:
        """Appel API asynchrone."""
        loop = asyncio.get_event_loop()
        return await loop.run_in_executor(
            None,
            lambda: self._api_call(method, endpoint, **kwargs)
        )

    async def _fetch_multiple(
        self,
        requests: List[Tuple[str, str, Dict]]
    ) -> List[Dict[str, Any]]:
        """R√©cup√®re plusieurs endpoints en parall√®le."""
        tasks = [
            self._api_call_async(method, endpoint, **kwargs)
            for method, endpoint, kwargs in requests
        ]
        return await asyncio.gather(*tasks)

# UTILISATION
async def get_full_state_async(device_serial: str):
    requests = [
        ('get', '/api/np/player', {'params': {...}}),
        ('get', '/api/media/state', {'params': {...}}),
        ('get', '/api/np/queue', {'params': {...}}),
    ]
    results = await playback_mgr._fetch_multiple(requests)
    # ‚è±Ô∏è Total: ~300ms (parall√®le)
```

**Files √† cr√©er:**

- [ ] `core/async_wrapper.py` - AsyncBaseManager
- [ ] `core/music/playback_manager_async.py` - Version async

**Note:** √Ä faire APR√àS Phase 1-3 (redondance √©limin√©e)

---

## 5. DISTRIBUTION & INITIALISATION

### 5.1 Cr√©er Dependency Injection Container

**Impact:** üü° **MOYEN** | **Effort:** üü° **MOYEN** (2 jours)

**Probl√®me:**

```python
# ACTUELLEMENT: Initialisations dispers√©es dans cli/context.py (300+ lignes)
class Context:
    def __init__(self, auth, config):
        self.device_mgr = DeviceManager(auth, config, ...)
        self.alarm_mgr = AlarmManager(auth, config, ...)
        # ... 30 managers, code dupliqu√©
```

**Solution - DI Container:**

```python
# CR√âER: core/di_container.py
from typing import TypeVar, Generic, Callable, Dict, Any

T = TypeVar('T')

class DIContainer:
    """Conteneur IoC pour gestion d√©pendances."""

    def __init__(self):
        self._factories: Dict[str, Callable] = {}
        self._singletons: Dict[str, Any] = {}

    def register_factory(self, name: str, factory: Callable):
        """Enregistre factory (nouvelle instance chaque fois)."""
        self._factories[name] = factory

    def register_singleton(self, name: str, factory: Callable):
        """Enregistre singleton (une seule instance)."""
        self._factories[name] = factory
        self._singletons[name] = None

    def get(self, name: str) -> Any:
        """R√©cup√®re instance."""
        if name in self._singletons:
            if self._singletons[name] is None:
                self._singletons[name] = self._factories[name]()
            return self._singletons[name]

        if name in self._factories:
            return self._factories[name]()

        raise KeyError(f"Service '{name}' non enregistr√©")

    def get_all(self) -> Dict[str, Any]:
        """R√©cup√®re tous les singletons."""
        return {
            name: self.get(name)
            for name in self._singletons
        }

# UTILISATION
# CR√âER: core/di_setup.py
def setup_container(auth: AlexaAuth, config: Config) -> DIContainer:
    """Initialise conteneur avec tous les managers."""
    container = DIContainer()

    # Singletons (une instance partag√©e)
    container.register_singleton(
        "state_machine",
        lambda: AlexaStateMachine()
    )
    container.register_singleton(
        "cache_service",
        lambda: CacheService()
    )

    # Managers
    container.register_singleton(
        "device_mgr",
        lambda: DeviceManager(
            auth,
            config,
            container.get("state_machine"),
            container.get("cache_service")
        )
    )

    container.register_singleton(
        "alarm_mgr",
        lambda: AlarmManager(
            auth,
            config,
            container.get("state_machine"),
            container.get("cache_service")
        )
    )

    # ... etc pour tous les 30+ managers

    return container

# DANS Context
class Context:
    def __init__(self, auth, config):
        self.container = setup_container(auth, config)

        # Lazy properties
        @property
        def device_mgr(self):
            return self.container.get("device_mgr")

        @property
        def alarm_mgr(self):
            return self.container.get("alarm_mgr")
```

**Files √† cr√©er/modifier:**

- [ ] `core/di_container.py` - Cr√©er DIContainer
- [ ] `core/di_setup.py` - Setup conteneur
- [ ] `cli/context.py` - Utiliser DI container (r√©duire 300+ lignes)

---

## 6. INT√âGRATION CLI

### 6.1 Ajouter Autocomplete pour Arguments

**Impact:** üü¢ **BAS** | **Effort:** üü° **MOYEN** (2 jours)

**Probl√®me:**

```bash
$ alexa device list --device <TAB>
# Rien n'appara√Æt - pas de completion

# Devrait proposer:
# - Noms devices depuis cache
# - Serials depuis API
```

**Solution - Argcomplete Integration:**

```python
# MODIFIER: cli/command_parser.py
import argcomplete

def setup_argcomplete(parser: argparse.ArgumentParser):
    """Configure argcomplete pour tous les parsers."""

    # Device completer
    def device_completer(prefix, **kwargs):
        """Compl√®te names de devices."""
        try:
            ctx = Context.get_current()
            devices = ctx.device_mgr.list_devices()
            names = [d.get('deviceName', '') for d in devices]
            return [n for n in names if n.startswith(prefix)]
        except:
            return []

    # Ajouter √† parser
    device_arg = parser.add_argument('--device', '-d')
    device_arg.completer = device_completer

    # Activer argcomplete
    argcomplete.autocomplete(parser)

# DANS cli/alexa_cli.py
parser = create_parser()
setup_argcomplete(parser)
```

**Installation:**

```bash
eval "$(register-python-argcomplete alexa)"
```

**Files √† modifier:**

- [ ] `cli/command_parser.py` - Setup argcomplete
- [ ] `cli/alexa_cli.py` - Enable argcomplete

---

### 6.2 Ajouter Commandes Admin (setup, config, debug)

**Impact:** üü° **MOYEN** | **Effort:** üü° **MOYEN** (2 jours)

**Nouveaux Commands:**

```bash
# Setup initial
$ alexa admin setup

# Configuration
$ alexa admin config show
$ alexa admin config set DEBUG true
$ alexa admin config reset

# Debug/Diagnostics
$ alexa admin diagnose
$ alexa admin logs --tail 100
$ alexa admin cache status
$ alexa admin cache clear
```

**Files √† cr√©er:**

- [ ] `cli/commands/admin.py` - Admin commands group
- [ ] `cli/help_texts/admin_help.py` - Help texts

---

## 7. TESTS & VALIDATION

### 7.1 Augmenter Coverage √† 85%+

**Impact:** üü° **MOYEN** | **Effort:** üî¥ **DIFFICILE** (4-5 jours)

**Coverage Actuel:** ~45% (Dev/pytests/)

**√Ä tester en priorit√©:**

- [ ] `core/base_manager.py` - **\_api_call, \_get_api_headers** (30+ scenarios)
- [ ] `core/circuit_breaker.py` - **Tous √©tats** (open, half-open, closed)
- [ ] `core/state_machine.py` - **Transitions d'√©tats** (20+ scenarios)
- [ ] `core/security/validators.py` - **Tous validators** (50+ cas edge)
- [ ] `cli/commands/*` - **Commandes utilisateur** (100+ scenarios)

**Cr√©er:**

- [ ] `Dev/pytests/test_base_manager_full.py` - ~300 lignes
- [ ] `Dev/pytests/test_circuit_breaker_full.py` - ~200 lignes
- [ ] `Dev/pytests/test_state_machine_full.py` - ~200 lignes
- [ ] `Dev/pytests/test_validators_full.py` - ~250 lignes
- [ ] `Dev/pytests/test_cli_commands.py` - ~400 lignes

**Commande:**

```bash
python -m pytest Dev/pytests/ --cov=. --cov-report=html
# Target: 85%+ coverage
```

---

### 7.2 Ajouter Performance Benchmarks

**Impact:** üü° **MOYEN** | **Effort:** üü° **MOYEN** (2 jours)

**Benchmarks √† ajouter:**

```python
# Dev/pytests/test_performance.py

def benchmark_api_call_latency():
    """Mesure latence _api_call."""
    # Target: < 500ms pour appel API simple

def benchmark_cache_hit():
    """Mesure vitesse cache m√©moire."""
    # Target: < 1ms pour cache hit

def benchmark_multiple_managers_init():
    """Mesure temps initialisation tous managers."""
    # Target: < 500ms pour 30+ managers

def benchmark_command_execution():
    """Mesure temps ex√©cution commands CLI."""
    # Target: < 1s par command
```

---

## 8. DOCUMENTATION

### 8.1 Ajouter Architecture Decision Records (ADR)

**Impact:** üü¢ **BAS** | **Effort:** üü° **MOYEN** (1-2 jours)

**ADRs √† cr√©er:**

```
Dev/docs/adr/
‚îú‚îÄ‚îÄ ADR-001-basemanager-inheritance.md
‚îú‚îÄ‚îÄ ADR-002-circuit-breaker-registry.md
‚îú‚îÄ‚îÄ ADR-003-csrf-centralization.md
‚îú‚îÄ‚îÄ ADR-004-repository-pattern.md
‚îú‚îÄ‚îÄ ADR-005-di-container.md
‚îî‚îÄ‚îÄ ADR-006-async-implementation.md
```

**Template ADR:**

```markdown
# ADR-00X: Titre

## Status

[PROPOSED | ACCEPTED | SUPERSEDED]

## Context

Probl√®me √† r√©soudre...

## Decision

Solution choisie...

## Consequences

Avantages/Inconv√©nients...

## Alternatives Consid√©r√©es

1. ...
2. ...
```

---

### 8.2 G√©n√©rer API Documentation Sphinx

**Impact:** üü¢ **BAS** | **Effort:** üü° **MOYEN** (2 jours)

```bash
# G√©n√©rer docs
sphinx-quickstart Dev/sphinx_docs
sphinx-apidoc -o Dev/sphinx_docs/source .
make html

# Output: Dev/sphinx_docs/_build/html/index.html
```

**Files √† cr√©er:**

- [ ] `Dev/sphinx_docs/conf.py` - Configuration Sphinx
- [ ] `Dev/sphinx_docs/Makefile` - Build sphinx

---

## üìä Summary & Priority Matrix

| #   | T√¢che                           | Impact      | Effort   | Priority | Days |
| --- | ------------------------------- | ----------- | -------- | -------- | ---- |
| 1.1 | Merger managers non-BaseManager | üî¥ CRITIQUE | üü° MOYEN | üî¥ P0    | 2-3  |
| 1.2 | Centraliser CircuitBreaker      | üü° MOYEN    | üü° MOYEN | üü° P1    | 1-2  |
| 1.3 | Extraire patterns CLI           | üü° MOYEN    | üü° MOYEN | üü° P1    | 2-3  |
| 2.1 | Normaliser initialisation       | üü¢ BAS      | üü° MOYEN | üü° P1    | 1-2  |
| 2.2 | Repository Pattern              | üü° MOYEN    | üî¥ DIFF  | üü¢ P2    | 3-4  |
| 3.1 | Centraliser CSRF                | üü° MOYEN    | üü° MOYEN | üî¥ P0    | 2    |
| 3.2 | Input Validation                | üü° MOYEN    | üü° MOYEN | üî¥ P0    | 2-3  |
| 4.1 | Pagination                      | üü° MOYEN    | üü° MOYEN | üü¢ P2    | 1-2  |
| 4.2 | Async/Await                     | üü° MOYEN    | üî¥ DIFF  | üü¢ P3    | 4-5  |
| 5.1 | DI Container                    | üü° MOYEN    | üü° MOYEN | üü° P1    | 2    |
| 6.1 | Autocomplete                    | üü¢ BAS      | üü° MOYEN | üü¢ P2    | 2    |
| 6.2 | Admin Commands                  | üü° MOYEN    | üü° MOYEN | üü¢ P2    | 2    |
| 7.1 | Coverage 85%                    | üü° MOYEN    | üî¥ DIFF  | üü° P1    | 4-5  |
| 7.2 | Benchmarks                      | üü¢ BAS      | üü° MOYEN | üü¢ P2    | 2    |
| 8.1 | ADRs                            | üü¢ BAS      | üü° MOYEN | üü¢ P2    | 1-2  |
| 8.2 | Sphinx Docs                     | üü¢ BAS      | üü° MOYEN | üü¢ P3    | 2    |

**Total Estimation:** **30-45 jours** (6-9 semaines)

### Recommended Phases

**Phase 1: S√©curit√© & Redondance (Semaine 1-2)**

- [ ] 3.1 CSRF Centralization ‚ö†Ô∏è SECURIT√â
- [ ] 3.2 Input Validation ‚ö†Ô∏è S√âCURIT√â
- [ ] 1.1 Merger managers
- [ ] 1.2 CircuitBreaker registry

**Phase 2: Architecture & Tests (Semaine 3-4)**

- [ ] 2.1 ManagerFactory
- [ ] 5.1 DI Container
- [ ] 1.3 CLI patterns
- [ ] 7.1 Coverage 85%

**Phase 3: Optimisations & Helpers (Semaine 5-6)**

- [ ] 2.2 Repository Pattern
- [ ] 4.1 Pagination
- [ ] 6.1 Autocomplete
- [ ] 6.2 Admin Commands

**Phase 4: Advanced & Docs (Semaine 7-9)**

- [ ] 4.2 Async/Await (optionnel)
- [ ] 7.2 Benchmarks
- [ ] 8.1 ADRs
- [ ] 8.2 Sphinx Docs

---

## üöÄ Next Steps

1. **Valider priorit√©s** avec √©quipe
2. **Cr√©er issues GitHub** pour chaque t√¢che
3. **Estimer velocit√©** (points story)
4. **Planifier sprints** (2 semaines)
5. **Commencer Phase 1** (S√©curit√© + Redondance)

---

**Auteur:** AI Assistant  
**Date Cr√©ation:** 16 octobre 2025  
**Derni√®re Mise √† Jour:** 16 octobre 2025  
**Status:** üü° EN R√âVISION
