"""
Service de commandes vocales - Format dev exact.

Utilise /api/behaviors/preview avec type "Alexa.Speak" pour
simuler des commandes vocales comme "Alexa, allume buffet".
"""

import json
import threading

# Import retard√© pour √©viter cycle avec core.smart_home
from typing import TYPE_CHECKING, Any, Dict, List, Optional, Tuple, cast

from loguru import logger

from utils.logger import SharedIcons

if TYPE_CHECKING:
    pass


class VoiceCommandService:
    """
    Service de commandes vocales - Architecture dev.

    Envoie des commandes textuelles qui sont interpr√©t√©es comme
    des commandes vocales par Alexa (TTS + ex√©cution).
    """

    def __init__(self, auth: Any, config: Any, state_machine: Optional[Any] = None):
        """
        Initialise le service.

        Args:
            auth: Service d'authentification
            config: Configuration
            state_machine: Machine √† √©tats (optionnel)
        """
        self.auth = auth
        self.config = config

        # Import au runtime pour √©viter cycles
        # Best-effort typing: initialize attributes as Any so mypy can track assignments
        self.state_machine: Any
        self.breaker: Any

        # Try runtime imports to avoid import cycles; fall back to TYPE_CHECKING names
        try:
            from core.circuit_breaker import CircuitBreaker
            from core.state_machine import AlexaStateMachine

            # Use lowercase local names for runtime creation while keeping
            # the imported names CamelCase to satisfy linters.
            cb = CircuitBreaker
            asm = AlexaStateMachine

            self.state_machine = state_machine or asm()
            self.breaker = cb(failure_threshold=3, timeout=30)
        except Exception:
            # If imports fail (import cycle), try to use names defined under TYPE_CHECKING
            # They may be None at runtime; guard their use accordingly.
            if state_machine is not None:
                self.state_machine = state_machine
            else:
                # Last resort: leave uninitialized (mypy will accept Any)
                self.state_machine = None

            try:
                from core.circuit_breaker import CircuitBreaker

                self.breaker = CircuitBreaker(failure_threshold=3, timeout=30)
            except Exception:
                self.breaker = None

        self._lock: threading.RLock = threading.RLock()
        self._customer_id: Optional[str] = None

        # Compatibilit√© legacy: exposer un http_client minimal via BaseManager wrapper
        try:
            from core.base_manager import create_http_client_from_auth

            # Normalize http client: wrap legacy auth.session or accept modern http client
            self.http_client = create_http_client_from_auth(self.auth)
        except Exception:
            # Fallback conservative: keep existing auth object as http client
            self.http_client = self.auth

        logger.info(f"{SharedIcons.GEAR} VoiceCommandService initialis√©")

    def speak(
        self, text: str, device_serial: Optional[str] = None, device_type: str = "ECHO"
    ) -> bool:  # pylint: disable=unused-argument
        """
        Fait parler Alexa et ex√©cute la commande vocale.

        Args:
            text: Texte √† dire (ex: "Alexa, allume buffet")
            device_serial: Serial du device (si None, utilise ALEXA_CURRENT_DSN)
            device_type: Type de device (d√©faut: ECHO)

        Returns:
            True si succ√®s, False sinon

        Exemples:
            >>> service.speak("Alexa, allume buffet")
            >>> service.speak("allume buffet", "G090LF11480501CV")
        """
        with self._lock:
            if not self.state_machine.can_execute_commands:
                logger.warning("‚ùå √âtat syst√®me ne permet pas l'ex√©cution")
                return False

            try:
                # ‚Üê NE PAS pr√©fixer avec "Alexa," pour TextCommand !
                # TextCommand envoie directement la commande, pas besoin du wake word
                text_clean = text.strip("\"'")
                if text_clean.lower().startswith("alexa"):
                    # Retirer "Alexa," si pr√©sent
                    text_clean = text_clean[6:].strip(",").strip()

                logger.debug(f"üìù Commande nettoy√©e: '{text_clean}'")

                # R√©cup√©rer customer_id si n√©cessaire
                if not self._customer_id:
                    self._customer_id = self._get_customer_id()
                    if not self._customer_id:
                        logger.error("‚ùå Customer ID non disponible")
                        return False

                # Device serial et type
                if device_serial:
                    # R√©cup√©rer le deviceType depuis le cache pour ce serial
                    dsn = device_serial
                    from services.cache_service import CacheService

                    cache = CacheService()
                    devices_data = cache.get("devices") or {}
                    devices = devices_data.get("devices", []) if isinstance(devices_data, dict) else []
                    dtype = None
                    device_name = None
                    for dev in devices:
                        if dev.get("serialNumber") == device_serial:
                            # IMPORTANT: utiliser deviceType (ex: A2UONLFQW0PADH) PAS deviceFamily !
                            dtype = dev.get("deviceType")
                            device_name = dev.get("accountName")
                            break
                    if not dtype:
                        logger.error(f"‚ùå Device {device_serial} introuvable dans le cache")
                        return False
                    logger.debug(f"üîä Device: {device_name} (serial={dsn}, deviceType={dtype})")
                else:
                    # R√©cup√©rer un device Echo par d√©faut
                    default_device = self._get_default_echo_device()
                    if not default_device:
                        logger.error("‚ùå Aucun device Echo disponible")
                        return False
                    dsn = default_device["serial"]
                    dtype = default_device["type"]
                    logger.debug(f"üîä Device: {default_device['name']} (serial={dsn}, type={dtype})")

                # Construire le payload - FORMAT DEV EXACT
                _sequence_json_content = {
                    "@type": "com.amazon.alexa.behaviors.model.Sequence",
                    "startNode": {
                        "@type": "com.amazon.alexa.behaviors.model.OpaquePayloadOperationNode",
                        "type": "Alexa.TextCommand",
                        "skillId": "amzn1.ask.1p.tellalexa",
                        "operationPayload": {
                            "deviceType": dtype,
                            "deviceSerialNumber": dsn,
                            "locale": "fr-FR",
                            "customerId": self._customer_id,
                            "text": text_clean,
                        },
                    },
                }

                # sequenceJson doit √™tre une STRING (json.dumps)
                payload = {
                    "behaviorId": "PREVIEW",
                    "sequenceJson": json.dumps(_sequence_json_content),
                    "status": "ENABLED",
                }

                logger.debug(f"üì§ Envoi commande vocale: '{text_clean}'")
                logger.debug(f"üì¶ Device: {dtype} / {dsn}")
                logger.debug("üìã Payload type: Alexa.TextCommand")
                logger.debug(f"üìã Payload text: '{text_clean}'")

                # Appel direct
                response = self.http_client.post(
                    "https://alexa.amazon.fr/api/behaviors/preview",
                    headers={
                        "Content-Type": "application/json; charset=UTF-8",
                        "Referer": "https://alexa.amazon.fr/spa/index.html",
                        "Origin": "https://alexa.amazon.fr",
                        "csrf": getattr(self.http_client, "csrf", getattr(self.auth, "csrf", "")),
                    },
                    json=payload,
                )

                response.raise_for_status()

                # Log de la r√©ponse COMPL√àTE (si JSON)
                try:
                    response_data = response.json()
                    status_val = getattr(response, "status_code", "unknown")
                    body_str = json.dumps(response_data, indent=2)
                    logger.debug(f"üì• R√©ponse API compl√®te: status={status_val}")
                    logger.debug(f"üì• Body: {body_str}")
                except Exception as e:
                    status_val = getattr(response, "status_code", "unknown")
                    err_str = str(e)
                    logger.debug(f"üì• R√©ponse API: status={status_val}, no JSON body: {err_str}")

                logger.success(f"‚úÖ Commande vocale envoy√©e: '{text_clean}'")
                return True

            except Exception as e:
                logger.error(f"‚ùå Erreur commande vocale: {e}")
                return False

    def speak_as_voice(
        self, text: str, device_serial: Optional[str] = None, device_type: str = "ECHO"
    ) -> bool:  # pylint: disable=unused-argument
        """
        Simule une commande vocale avec Alexa.Speak (comme si on parlait au micro).

        Diff√©rence avec speak():
        - speak() utilise TextCommand (trait√© comme texte)
        - speak_as_voice() utilise Alexa.Speak (trait√© comme voix)

        Args:
            text: Commande vocale (ex: "donne-moi la liste des choses √† faire")
            device_serial: Serial du device (si None, utilise ALEXA_CURRENT_DSN)
            device_type: Type de device (d√©faut: ECHO)

        Returns:
            True si succ√®s, False sinon
        """
        with self._lock:
            if not self.state_machine.can_execute_commands:
                logger.warning("‚ùå √âtat syst√®me ne permet pas l'ex√©cution")
                return False

            try:
                text_clean = text.strip("\"'")
                if text_clean.lower().startswith("alexa"):
                    text_clean = text_clean[6:].strip(",").strip()

                logger.debug(f"üìù Commande vocale simul√©e: '{text_clean}'")

                # R√©cup√©rer customer_id si n√©cessaire
                if not self._customer_id:
                    self._customer_id = self._get_customer_id()
                    if not self._customer_id:
                        logger.error("‚ùå Customer ID non disponible")
                        return False

                # Device serial et type
                if device_serial:
                    from services.cache_service import CacheService

                    cache = CacheService()
                    devices_data = cache.get("devices") or {}
                    devices = devices_data.get("devices", [])
                    dtype = None
                    device_name = None
                    for dev in devices:
                        if dev.get("serialNumber") == device_serial:
                            dtype = dev.get("deviceType")
                            device_name = dev.get("accountName")
                            break
                    if not dtype:
                        logger.error(f"‚ùå Device {device_serial} introuvable dans le cache")
                        return False
                    logger.debug(f"üîä Device: {device_name} (serial={device_serial}, deviceType={dtype})")
                else:
                    default_device = self._get_default_echo_device()
                    if not default_device:
                        logger.error("‚ùå Aucun device Echo disponible")
                        return False
                    device_serial = default_device["serial"]
                    dtype = default_device["type"]
                    logger.debug(f"üîä Device: {default_device['name']} (serial={device_serial}, type={dtype})")

                # Construire le payload avec Alexa.Speak au lieu de TextCommand
                # Cela simule une VRAIE commande vocale (comme si on parlait au micro)
                _sequence_json_content = {
                    "@type": "com.amazon.alexa.behaviors.model.Sequence",
                    "startNode": {
                        "@type": "com.amazon.alexa.behaviors.model.OpaquePayloadOperationNode",
                        "type": "Alexa.Speak",
                        "operationPayload": {
                            "deviceType": dtype,
                            "deviceSerialNumber": device_serial,
                            "locale": "fr-FR",
                            "customerId": self._customer_id,
                            "textToSpeak": text_clean,
                        },
                    },
                }

                payload = {
                    "behaviorId": "PREVIEW",
                    "sequenceJson": json.dumps(_sequence_json_content),
                    "status": "ENABLED",
                }

                logger.debug(f"üì§ Envoi commande vocale simul√©e: '{text_clean}'")
                logger.debug(f"üì¶ Device: {dtype} / {device_serial}")

                response = self.http_client.post(
                    "https://alexa.amazon.fr/api/behaviors/preview",
                    headers={
                        "Content-Type": "application/json; charset=UTF-8",
                        "Referer": "https://alexa.amazon.fr/spa/index.html",
                        "Origin": "https://alexa.amazon.fr",
                        "csrf": getattr(self.http_client, "csrf", getattr(self.auth, "csrf", "")),
                    },
                    json=payload,
                )

                response.raise_for_status()

                try:
                    response_data = response.json() if hasattr(response, "json") else {}
                    logger.debug(f"üì• R√©ponse API: status={response.status_code}")
                    logger.debug(f"üì• Body: {json.dumps(response_data, indent=2)}")
                except Exception as e:
                    logger.debug(f"üì• R√©ponse API: status={response.status_code}, no JSON body: {e}")

                logger.success(f"‚úÖ Commande vocale simul√©e envoy√©e: '{text_clean}'")
                return True

            except Exception as e:
                logger.error(f"‚ùå Erreur commande vocale simul√©e: {e}")
                return False

    def _get_default_echo_device(self) -> Optional[Dict[str, Any]]:
        """
        R√©cup√®re un device Echo par d√©faut pour ex√©cuter les commandes vocales.

        Returns:
            Dict avec {name, serial, type} ou None si aucun device disponible
        """
        try:
            # R√©cup√©rer la liste des devices depuis le cache
            from services.cache_service import CacheService

            cache = CacheService()
            devices_data = cache.get("devices")

            if not devices_data:
                logger.warning("‚ö†Ô∏è Aucun device en cache")
                return None

            # ‚Üê FIX: devices_data contient d√©j√† {"devices": [...]}
            devices = devices_data.get("devices", []) if isinstance(devices_data, dict) else devices_data

            # Chercher un Echo (priorit√©: Salon Echo, sinon premier Echo disponible)
            echo_devices: List[Dict[str, Any]] = []
            for device in devices:
                device_family = device.get("deviceFamily", "")
                # KNIGHT, ROOK, etc. sont des familles Echo
                if device_family in ["KNIGHT", "ROOK", "VOX", "ECHO"]:
                    echo_devices.append(
                        {
                            "name": device.get("accountName", "Unknown"),
                            "serial": device.get("serialNumber", ""),
                            "type": device.get("deviceType"),  # ‚Üê IMPORTANT: deviceType, PAS deviceFamily !
                        }
                    )

            if not echo_devices:
                logger.error("‚ùå Aucun device Echo trouv√©")
                return None

            # Priorit√©: "Salon Echo"
            for echo in echo_devices:
                if "salon" in echo["name"].lower():
                    return echo

            # Sinon, premier Echo disponible
            return echo_devices[0]

        except Exception as e:
            logger.error(f"‚ùå Erreur r√©cup√©ration device Echo: {e}")
            return None

    def _get_customer_id(self) -> Optional[str]:
        """
        R√©cup√®re le customer ID via /api/bootstrap.

        Returns:
            Customer ID ou None si erreur
        """
        try:
            url = f"https://{self.config.alexa_domain}/api/bootstrap?version=0"
            response = self.breaker.call(
                self.http_client.get,
                url,
                headers={"csrf": getattr(self.http_client, "csrf", getattr(self.auth, "csrf", ""))},
                timeout=10,
            )
            response.raise_for_status()
            data = response.json()

            customer_id = data.get("authentication", {}).get("customerId")
            if customer_id:
                logger.debug(f"‚úÖ Customer ID: {customer_id}")
                return cast(str | None, customer_id)
            else:
                logger.warning("‚ö†Ô∏è Customer ID non trouv√© dans bootstrap")
                return None

        except Exception as e:
            logger.error(f"‚ùå Erreur r√©cup√©ration customer ID: {e}")
            return None

    def turn_on_light(self, light_name: str, device_serial: Optional[str] = None) -> bool:
        """
        Allume une lumi√®re.

        Args:
            light_name: Nom de la lumi√®re (ex: "buffet", "salon")
            device_serial: Serial du device Alexa (optionnel)

        Returns:
            True si succ√®s
        """
        return self.speak(f"allume {light_name}", device_serial)

    def turn_off_light(self, light_name: str, device_serial: Optional[str] = None) -> bool:
        """
        √âteint une lumi√®re.

        Args:
            light_name: Nom de la lumi√®re
            device_serial: Serial du device Alexa (optionnel)

        Returns:
            True si succ√®s
        """
        return self.speak(f"√©teins {light_name}", device_serial)

    def set_brightness(self, light_name: str, brightness: int, device_serial: Optional[str] = None) -> bool:
        """
        D√©finit la luminosit√©.

        Args:
            light_name: Nom de la lumi√®re
            brightness: Luminosit√© 0-100
            device_serial: Serial du device Alexa (optionnel)

        Returns:
            True si succ√®s
        """
        if not 0 <= brightness <= 100:
            logger.error(f"‚ùå Luminosit√© invalide: {brightness} (0-100)")
            return False
        return self.speak(f"mets {light_name} √† {brightness} pourcent", device_serial)

    def set_color(self, light_name: str, color: str, device_serial: Optional[str] = None) -> bool:
        """
        D√©finit la couleur.

        Args:
            light_name: Nom de la lumi√®re
            color: Nom de couleur (rouge, bleu, vert, etc.)
            device_serial: Serial du device Alexa (optionnel)

        Returns:
            True si succ√®s
        """
        return self.speak(f"mets {light_name} en {color}", device_serial)

    def ask_and_get_response(
        self, question: str, device_serial: Optional[str] = None, wait_seconds: float = 2.0
    ) -> Optional[str]:
        """
        Pose une question vocale √† Alexa et r√©cup√®re la r√©ponse.

        Utilise TextCommand pour poser la question, puis r√©cup√®re
        la r√©ponse d'Alexa via l'API Privacy (historique vocal).

        Args:
            question: Question √† poser (ex: "lis ma liste de courses")
            device_serial: Serial du device (optionnel)
            wait_seconds: Temps d'attente avant de r√©cup√©rer la r√©ponse (d√©faut: 2s)

        Returns:
            R√©ponse vocale d'Alexa ou None si √©chec

        Exemples:
            >>> response = service.ask_and_get_response("lis ma liste de courses")
            >>> print(response)  # "Voici votre liste de courses : lait, pain, ..."
        """
        import time

        with self._lock:
            if not self.state_machine.can_execute_commands:
                logger.warning("‚ùå √âtat syst√®me ne permet pas l'ex√©cution")
                return None

            try:
                # 1. Enregistrer le timestamp avant l'envoi
                import datetime as _datetime

                timestamp_before = _datetime.datetime.now()

                # 2. Envoyer la commande vocale
                logger.info(f"üì§ Envoi commande √† Alexa: '{question}'")
                success = self.speak(question, device_serial)

                if not success:
                    logger.error("‚ùå √âchec de l'envoi de la commande")
                    return None

                logger.success("‚úÖ Commande envoy√©e avec succ√®s")

                # 3. Attendre que Alexa traite et r√©ponde
                logger.info(f"‚è≥ Attente de {wait_seconds}s pour que Alexa r√©ponde...")
                for i in range(int(wait_seconds)):
                    time.sleep(1)
                    logger.debug(f"   {i + 1}/{int(wait_seconds)}s...")

                # Attendre le reste (d√©cimales)
                remaining = wait_seconds - int(wait_seconds)
                if remaining > 0:
                    time.sleep(remaining)

                # 4. R√©cup√©rer la derni√®re r√©ponse via l'API Privacy
                logger.info("üîç R√©cup√©ration de la r√©ponse d'Alexa...")

                # ActivityManager removed - simplified response retrieval
                logger.warning("‚ö†Ô∏è ActivityManager supprim√© - r√©cup√©ration de r√©ponse simplifi√©e")
                return None

            except Exception as e:
                logger.exception(f"‚ùå Erreur lors de la r√©cup√©ration de la r√©ponse: {e}")
                return None

    def play_sound(self, device_name: str, sound_id: str) -> bool:
        """
        Joue un son d'effet sur l'appareil.

        Args:
            device_name: Nom de l'appareil
            sound_id: ID du son (ex: amzn1.ask.skillId.airhorn)

        Returns:
            True si le son a √©t√© jou√©, False sinon
        """
        with self._lock:
            try:
                logger.debug(f"üîä Jouant son {sound_id} sur {device_name}")

                # R√©cup√©rer customer_id
                if not self._customer_id:
                    self._customer_id = self._get_customer_id()
                    if not self._customer_id:
                        logger.error("‚ùå Customer ID non disponible")
                        return False

                # R√©cup√©rer le device depuis le cache
                from services.cache_service import CacheService

                cache = CacheService()
                devices_data = cache.get("devices") or {}
                devices = devices_data.get("devices", [])

                device_serial = None
                device_type = None
                for dev in devices:
                    if dev.get("accountName") == device_name:
                        device_serial = dev.get("serialNumber")
                        device_type = dev.get("deviceType")
                        break

                if not device_serial or not device_type:
                    logger.error(f"‚ùå Appareil '{device_name}' non trouv√©")
                    return False

                logger.debug(f"üîä Device trouv√©: {device_name} (serial={device_serial})")

                return self.speak_as_voice(f"Sound: {sound_id}", device_serial, device_type)

            except Exception as e:
                logger.exception(f"‚ùå Erreur lors de la lecture du son: {e}")
                return False

    def execute_text_command(self, device_name: str, text: str) -> bool:
        """
        Ex√©cute une commande texte (comme si elle √©tait vocale).

        Args:
            device_name: Nom de l'appareil
            text: Commande texte √† ex√©cuter (ex: 'allume les lumi√®res')

        Returns:
            True si la commande a √©t√© ex√©cut√©e, False sinon
        """
        with self._lock:
            try:
                logger.debug(f"üìù Ex√©cutant commande texte: '{text}' sur {device_name}")

                # R√©cup√©rer customer_id
                if not self._customer_id:
                    self._customer_id = self._get_customer_id()
                    if not self._customer_id:
                        logger.error("‚ùå Customer ID non disponible")
                        return False

                # R√©cup√©rer le device depuis le cache
                from services.cache_service import CacheService

                cache = CacheService()
                devices_data = cache.get("devices") or {}
                devices = devices_data.get("devices", [])

                device_serial = None
                device_type = None
                for dev in devices:
                    if dev.get("accountName") == device_name:
                        device_serial = dev.get("serialNumber")
                        device_type = dev.get("deviceType")
                        break

                if not device_serial or not device_type:
                    logger.error(f"‚ùå Appareil '{device_name}' non trouv√©")
                    return False

                logger.debug(f"üìù Device trouv√©: {device_name} (serial={device_serial})")

                # Construire le payload pour ex√©cuter la commande texte
                sequence_json_content = {
                    "@type": "com.amazon.alexa.behaviors.model.Sequence",
                    "startNode": {
                        "@type": "com.amazon.alexa.behaviors.model.OpaquePayloadOperationNode",
                        "type": "Alexa.TextCommand",
                        "operationPayload": {
                            "deviceType": device_type,
                            "deviceSerialNumber": device_serial,
                            "locale": "fr-FR",
                            "customerId": self._customer_id,
                            "text": text,
                            "skillId": "amzn1.ask.1p.tellalexa",
                        },
                    },
                }

                payload = {
                    "behaviorId": "PREVIEW",
                    "sequenceJson": sequence_json_content,
                    "status": "ENABLED",
                }

                # Envoyer la commande
                result = self.auth.post_api(
                    "/api/behaviors/preview",
                    json=payload,
                    headers={"Origin": "https://alexa.amazon.fr"},
                )

                if result and result.status_code == 200:
                    logger.success(f"‚úÖ Commande texte ex√©cut√©e: '{text}'")
                    return True
                else:
                    logger.error(f"‚ùå Erreur lors de l'ex√©cution: {result.status_code if result else 'No response'}")
                    return False

            except Exception as e:
                logger.exception(f"‚ùå Erreur lors de l'ex√©cution du textcommand: {e}")
                return False
