"""
Gestionnaire de listes (courses, t√¢ches) - Thread-safe.
Utilise des commandes vocales (TextCommand) pour g√©rer les listes.
"""

import threading
from typing import Any, Dict, List, Optional

from loguru import logger

from ..circuit_breaker import CircuitBreaker
from ..state_machine import AlexaStateMachine


class ListsManager:
    """Gestionnaire thread-safe des listes via commandes vocales."""

    def __init__(self, auth, config, state_machine=None, voice_service=None):
        self.auth = auth
        self.config = config
        self.state_machine = state_machine or AlexaStateMachine()
        self.breaker = CircuitBreaker(failure_threshold=3, timeout=30)
        self._lock = threading.RLock()
        self._voice_service = voice_service
        try:
            from core.base_manager import create_http_client_from_auth

            self.http_client = create_http_client_from_auth(self.auth)
        except Exception:
            self.http_client = self.auth
        logger.info("ListManager initialis√© (mode commandes vocales)")

    @property
    def voice_service(self):
        """Lazy loading du VoiceCommandService."""
        if self._voice_service is None:
            from services.voice_command_service import VoiceCommandService

            self._voice_service = VoiceCommandService(self.auth, self.config, self.state_machine)
        return self._voice_service

    def get_lists(self) -> List[Dict]:
        """
        R√©cup√®re toutes les listes via diff√©rents endpoints.

        Essaie plusieurs endpoints connus :
        1. /api/namedLists (endpoint standard mais peut √™tre vide)
        2. /api/todos (pour les listes de t√¢ches)
        3. /api/household/lists (endpoint alternatif)

        Note: Si tous √©chouent, utilisez les commandes vocales (add, remove, etc.).
        """
        with self._lock:
            if not self.state_machine.can_execute_commands:
                return []

            # Liste des endpoints √† tester
            endpoints = [
                ("/api/namedLists", "lists"),
                ("/api/todos", "values"),  # Retourne {"values": [...]}
                ("/api/household/lists", "lists"),
            ]

            for endpoint, key in endpoints:
                try:
                    logger.debug(f"üîç Test endpoint: {endpoint}")
                    response = self.breaker.call(
                        self.http_client.get,
                        f"https://{self.config.alexa_domain}{endpoint}",
                        headers={"csrf": getattr(self.http_client, "csrf", getattr(self.auth, "csrf", ""))},
                        timeout=10,
                    )
                    response.raise_for_status()
                    data = response.json()
                    lists = data.get(key, [])

                    if lists:
                        logger.success(f"‚úÖ Listes trouv√©es via {endpoint} ({len(lists)} liste(s))")
                        return lists
                    else:
                        logger.debug(f"‚ö†Ô∏è Endpoint {endpoint} retourne une liste vide")

                except Exception as e:
                    logger.debug(f"‚ùå Endpoint {endpoint} √©chou√©: {e}")
                    continue

            # Tous les endpoints ont √©chou√©
            logger.warning(
                "‚ö†Ô∏è Impossible de r√©cup√©rer les listes via les API REST. "
                "Les commandes vocales (add, remove) fonctionneront quand m√™me."
            )
            return []

    def get_list(self, list_name: str) -> Optional[Dict]:
        """R√©cup√®re une liste sp√©cifique par nom ou type.

        Args:
            list_name: Nom de la liste ('shopping', 'todo', ou nom personnalis√©)

        Returns:
            Dictionnaire de la liste ou None si non trouv√©e
        """
        lists = self.get_lists()

        # Recherche par type connu
        if list_name.lower() == "shopping":
            for lst in lists:
                if lst.get("type") == "SHOPPING_ITEM":
                    return lst
        elif list_name.lower() == "todo":
            for lst in lists:
                if lst.get("type") == "TASK":
                    return lst

        # Recherche par nom
        for lst in lists:
            if lst.get("name", "").lower() == list_name.lower():
                return lst

        return None

    def add_item(self, list_name: str, text: str, device_serial: Optional[str] = None) -> bool:
        """
        Ajoute un √©l√©ment √† une liste via commande vocale.

        Args:
            list_name: Nom de la liste ('shopping', 'todo', ou nom personnalis√©)
            text: Texte de l'√©l√©ment √† ajouter
            device_serial: Serial du device Alexa (optionnel, utilise un Echo par d√©faut)

        Returns:
            True si succ√®s
        """
        with self._lock:
            if not self.state_machine.can_execute_commands:
                return False
            try:
                # Mapper les noms de liste vers les commandes fran√ßaises
                list_commands = {
                    "shopping": "liste de courses",
                    "todo": "liste de t√¢ches",
                    "courses": "liste de courses",
                    "t√¢ches": "liste de t√¢ches",
                    "taches": "liste de t√¢ches",
                }

                list_target = list_commands.get(list_name.lower(), f"liste {list_name}")

                # Construire la commande vocale
                command = f"ajoute {text} √† ma {list_target}"

                logger.info(f"üìù Commande vocale: '{command}'")

                # Envoyer via VoiceCommandService avec device sp√©cifique
                success = self.voice_service.speak(command, device_serial=device_serial)

                if success:
                    logger.success(f"√âl√©ment '{text}' ajout√© √† '{list_name}'")
                else:
                    logger.error(f"√âchec ajout de '{text}'")

                return success

            except Exception as e:
                logger.error(f"Erreur ajout item: {e}")
                return False

    def remove_item(self, list_name: str, text: str, device_serial: Optional[str] = None) -> bool:
        """
        Supprime un √©l√©ment d'une liste via commande vocale.

        Args:
            list_name: Nom de la liste ('shopping', 'todo', ou nom personnalis√©)
            text: Texte de l'√©l√©ment √† supprimer
            device_serial: Serial du device Alexa (optionnel, utilise un Echo par d√©faut)

        Returns:
            True si succ√®s
        """
        with self._lock:
            if not self.state_machine.can_execute_commands:
                return False
            try:
                # Mapper les noms de liste
                list_commands = {
                    "shopping": "liste de courses",
                    "todo": "liste de t√¢ches",
                    "courses": "liste de courses",
                    "t√¢ches": "liste de t√¢ches",
                    "taches": "liste de t√¢ches",
                }

                list_target = list_commands.get(list_name.lower(), f"liste {list_name}")

                # Construire la commande vocale (utiliser "retire" au lieu de "supprime")
                command = f"retire {text} de ma {list_target}"

                logger.info(f"üìù Commande vocale: '{command}'")

                # Envoyer via VoiceCommandService avec device sp√©cifique
                success = self.voice_service.speak(command, device_serial=device_serial)

                if success:
                    logger.success(f"√âl√©ment '{text}' supprim√© de '{list_name}'")
                else:
                    logger.error(f"√âchec suppression de '{text}'")

                return success

            except Exception as e:
                logger.error(f"Erreur suppression item: {e}")
                return False

    def complete_item(self, list_name: str, text: str, device_serial: Optional[str] = None) -> bool:
        """
        Marque un √©l√©ment comme compl√©t√© via commande vocale.

        Args:
            list_name: Nom de la liste ('shopping', 'todo', ou nom personnalis√©)
            text: Texte de l'√©l√©ment √† marquer compl√©t√©
            device_serial: Serial du device Alexa (optionnel, utilise un Echo par d√©faut)

        Returns:
            True si succ√®s
        """
        with self._lock:
            if not self.state_machine.can_execute_commands:
                return False
            try:
                # Mapper les noms de liste
                list_commands = {
                    "shopping": "liste de courses",
                    "todo": "liste de t√¢ches",
                    "courses": "liste de courses",
                    "t√¢ches": "liste de t√¢ches",
                    "taches": "liste de t√¢ches",
                }

                list_target = list_commands.get(list_name.lower(), f"liste {list_name}")

                # Construire la commande vocale
                command = f"marque {text} comme fait dans ma {list_target}"

                logger.info(f"üìù Commande vocale: '{command}'")

                # Envoyer via VoiceCommandService avec device sp√©cifique
                success = self.voice_service.speak(command, device_serial=device_serial)

                if success:
                    logger.success(f"√âl√©ment '{text}' marqu√© compl√©t√© dans '{list_name}'")
                else:
                    logger.error(f"√âchec marquage de '{text}'")

                return success

            except Exception as e:
                logger.error(f"Erreur marquage item: {e}")
                return False

    def clear_list(self, list_name: str, completed_only: bool = False, device_serial: Optional[str] = None) -> bool:
        """
        Vide une liste via commande vocale.

        Args:
            list_name: Nom de la liste ('shopping', 'todo', ou nom personnalis√©)
            completed_only: Si True, supprime uniquement les √©l√©ments compl√©t√©s
            device_serial: Serial du device Alexa (optionnel, utilise un Echo par d√©faut)

        Returns:
            True si succ√®s
        """
        with self._lock:
            if not self.state_machine.can_execute_commands:
                return False
            try:
                # Mapper les noms de liste
                list_commands = {
                    "shopping": "liste de courses",
                    "todo": "liste de t√¢ches",
                    "courses": "liste de courses",
                    "t√¢ches": "liste de t√¢ches",
                    "taches": "liste de t√¢ches",
                }

                list_target = list_commands.get(list_name.lower(), f"liste {list_name}")

                # Construire la commande vocale
                if completed_only:
                    command = f"supprime les √©l√©ments termin√©s de ma {list_target}"
                else:
                    command = f"vide ma {list_target}"

                logger.info(f"üìù Commande vocale: '{command}'")

                # Envoyer via VoiceCommandService avec device sp√©cifique
                success = self.voice_service.speak(command, device_serial=device_serial)

                if success:
                    logger.success(f"Liste '{list_name}' vid√©e")
                else:
                    logger.error(f"√âchec vidage de '{list_name}'")

                return success

            except Exception as e:
                logger.error(f"Erreur vidage liste: {e}")
                return False

    def create_list(self, name: str, device_serial: Optional[str] = None) -> bool:
        """
        Cr√©e une nouvelle liste via commande vocale.

        Args:
            name: Nom de la nouvelle liste
            device_serial: Serial du device Alexa (optionnel, utilise un Echo par d√©faut)

        Returns:
            True si succ√®s
        """
        with self._lock:
            if not self.state_machine.can_execute_commands:
                return False
            try:
                # Construire la commande vocale
                command = f"cr√©e une liste {name}"

                logger.info(f"üìù Commande vocale: '{command}'")

                # Envoyer via VoiceCommandService avec device sp√©cifique
                success = self.voice_service.speak(command, device_serial=device_serial)

                if success:
                    logger.success(f"Liste '{name}' cr√©√©e")
                else:
                    logger.error(f"√âchec cr√©ation de '{name}'")

                return success

            except Exception as e:
                logger.error(f"Erreur cr√©ation liste: {e}")
                return False

    def get_shopping_list(self) -> Optional[Dict[str, Any]]:
        """Raccourci pour la liste de courses."""
        lists = self.get_lists()
        for lst in lists:
            if lst.get("type") == "SHOPPING_ITEM":
                return lst
        return None

    def get_todo_list(self) -> Optional[Dict[str, Any]]:
        """Raccourci pour la liste de t√¢ches."""
        lists = self.get_lists()
        for lst in lists:
            if lst.get("type") == "TASK":
                return lst
        return None
